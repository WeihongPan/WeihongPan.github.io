<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weihongpan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"mac","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="跬步千里">
<meta property="og:type" content="website">
<meta property="og:title" content="潘薇鸿">
<meta property="og:url" content="https://weihongpan.github.io/index.html">
<meta property="og:site_name" content="潘薇鸿">
<meta property="og:description" content="跬步千里">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="潘薇鸿">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://weihongpan.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>潘薇鸿</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">潘薇鸿</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">keep on fighting</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/WeihongPan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/SLAM/PCL%E5%AD%A6%E4%B9%A0-4-octree%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/SLAM/PCL%E5%AD%A6%E4%B9%A0-4-octree%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">PCL学习(4)-octree模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-13 16:35:55 / 修改时间：16:43:05" itemprop="dateCreated datePublished" datetime="2021-07-13T16:35:55+08:00">2021-07-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/SLAM/PCL%E5%AD%A6%E4%B9%A0-3-kd-tree%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/SLAM/PCL%E5%AD%A6%E4%B9%A0-3-kd-tree%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">PCL学习(3):kd-tree模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-13 11:26:20 / 修改时间：16:42:52" itemprop="dateCreated datePublished" datetime="2021-07-13T11:26:20+08:00">2021-07-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>kd-tree概念的基本介绍可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/silangquan/article/details/41483689">这篇博客</a> </p>
<p>PCL中的kd-tree库提供了kd-tree数据结构，基于FLANN进行<strong>快速最近邻检索</strong>。最近邻检索在<strong>匹配</strong>、<strong>特征描述子计算</strong>、<strong>邻域特征提取</strong>中是非常基础的核心操作。</p>
<p>kd-tree模块包括了三个类和两个函数，实现了利用kd-tree数据结构对点云进行高效管理和检索，依赖于 <code>pcl_common</code> 模块。</p>
<h4 id="kd-tree模块中的类"><a href="#kd-tree模块中的类" class="headerlink" title="kd-tree模块中的类"></a>kd-tree模块中的类</h4><p>三个类的继承关系如图：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-3-kd-tree%E6%A8%A1%E5%9D%97/1626155630734.png" alt="1626155630734"></p>
<p><a target="_blank" rel="noopener" href="https://pointclouds.org/documentation/classpcl_1_1_kd_tree.html"><code>pcl::KdTree&lt;PointT&gt;</code></a> </p>
<p>KdTree类实现了kd-tree的数据结构，关键成员函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">KdTree</span>(<span class="keyword">bool</span> sorted=<span class="literal">true</span>); <span class="comment">// 空的构造函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">KdTree</span>(); 		  <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">setInputCloud</span> <span class="params">(   </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> PointCloud::ConstPtr &amp;cloud, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> shared_ptr&lt;<span class="keyword">const</span> Indices&gt; &amp;indices=shared_ptr&lt;<span class="keyword">const</span> Indices&gt;())</span></span>;</span><br><span class="line"><span class="comment">// 设置输入点云，indices为点云在kd-tree中使用的点对应的索引，不设置则默认使用整个点云填充kd-tree</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEpsilon</span><span class="params">(<span class="keyword">float</span> eps)</span></span>; <span class="comment">// 设置误差限</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMinPts</span><span class="params">(<span class="keyword">int</span> min_pts)</span></span>; <span class="comment">// 设置k近邻搜索中可行结果的最小数目</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>virtual int nearestKSearch</code> </li>
</ul>
<p>纯虚函数，共有三种形式，具体实现在子类 <code>KdTreeFLANN</code> 中，用来进行K邻域搜索。</p>
<p>（1）根据提供的点云和待查询点的索引进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> pcl::KdTree&lt; PointT &gt;::<span class="built_in">nearestKSearch</span>(	</span><br><span class="line">    <span class="keyword">const</span> PointCloud &amp; 	 cloud,</span><br><span class="line">    <span class="keyword">int</span>   				 index,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 		 k,</span><br><span class="line">    Indices &amp;			 k_indices,</span><br><span class="line">    std::vector&lt;<span class="keyword">float</span>&gt; &amp; k_sqr_distances </span><br><span class="line">)<span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>[input] <strong>cloud</strong>：点云数据</p>
<p>[input] <strong>index</strong>：所查询点的索引（必须是有效的索引，该函数不会对有效性进行检查）</p>
<p>[input] <strong>k</strong>：K邻域个数</p>
<p>[output] <strong>k_indices</strong>：搜索完的邻域点对应的索引</p>
<p>[output] <strong>k_sqr_distances</strong>：搜索完的每个邻域点与查询点之间的欧氏距离</p>
<p>返回找到的邻域点个数</p>
<p>（2）根据提供的待查询点进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> pcl::KdTree&lt; PointT &gt;::<span class="built_in">nearestKSearch</span>(	</span><br><span class="line">    <span class="keyword">const</span> PointT &amp; 	 	 p_q,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 		 k,</span><br><span class="line">    Indices &amp;			 k_indices,</span><br><span class="line">    std::vector&lt;<span class="keyword">float</span>&gt; &amp; k_sqr_distances </span><br><span class="line">)<span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>[input] <strong>p_q</strong>：待查询点</p>
<p>其他与上同</p>
<p>（3）根据提供的待查询点索引进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> pcl::KdTree&lt; PointT &gt;::<span class="built_in">nearestKSearch</span>(	</span><br><span class="line">    <span class="keyword">int</span>   				 index,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 		 k,</span><br><span class="line">    Indices &amp;			 k_indices,</span><br><span class="line">    std::vector&lt;<span class="keyword">float</span>&gt; &amp; k_sqr_distances </span><br><span class="line">)<span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>virtual int radiusSearch</code> </li>
</ul>
<p>纯虚函数，类似<code>nearestKSearch</code>，共有三种形式，具体实现在子类 <code>KdTreeFLANN</code> 中，用来进行r半径内的邻域搜索。</p>
<p>（1）根据提供的点云和待查询点的索引进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> pcl::KdTree&lt; PointT &gt;::<span class="built_in">radiusSearch</span>(	</span><br><span class="line">    <span class="keyword">const</span> PointCloud &amp; 	 cloud,</span><br><span class="line">    <span class="keyword">int</span>   				 index,</span><br><span class="line">    <span class="keyword">double</span> 				 radius,    </span><br><span class="line">    Indices &amp;			 k_indices,</span><br><span class="line">    std::vector&lt;<span class="keyword">float</span>&gt; &amp; k_sqr_distances,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		 max_nn = <span class="number">0</span></span><br><span class="line">)<span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>[input] radius：搜索半径</p>
<p>[input] max_nn：设置返回的邻域点个数商店，若为0或大于返回邻域点个数，则返回全部搜索结果</p>
<p>其他与上同，返回半径内搜索到的邻域点个数</p>
<p>（2）根据提供的待查询点进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> pcl::KdTree&lt; PointT &gt;::<span class="built_in">radiusSearch</span>(	</span><br><span class="line">    <span class="keyword">const</span> PointT &amp; 	 	 p_q,</span><br><span class="line">    <span class="keyword">double</span> 				 radius,    </span><br><span class="line">    Indices &amp;			 k_indices,</span><br><span class="line">    std::vector&lt;<span class="keyword">float</span>&gt; &amp; k_sqr_distances,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		 max_nn = <span class="number">0</span></span><br><span class="line">)<span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>（3）根据提供的待查询点索引进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> pcl::KdTree&lt; PointT &gt;::<span class="built_in">radiusSearch</span>(	    </span><br><span class="line">    <span class="keyword">int</span>   				 index,</span><br><span class="line">    <span class="keyword">double</span> 				 radius,    </span><br><span class="line">    Indices &amp;			 k_indices,</span><br><span class="line">    std::vector&lt;<span class="keyword">float</span>&gt; &amp; k_sqr_distances,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		 max_nn = <span class="number">0</span></span><br><span class="line">)<span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pointclouds.org/documentation/classpcl_1_1_kd_tree_f_l_a_n_n.html">pcl::KdTreeFLANN<PointT, dist></PointT,></a> </p>
<p>基本与上无差别，具体参见官方手册</p>
<h4 id="ke-tree-模块中的全局函数"><a href="#ke-tree-模块中的全局函数" class="headerlink" title="ke-tree 模块中的全局函数"></a>ke-tree 模块中的全局函数</h4><p><code>void pcl::getApproximateIndices</code> </p>
<p>获取参考点云中查询点云的近似索引向量（两个点云的坐标类型可以不同）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PointT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcl::getApproximateIndices</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">typename</span> pcl::PointCloud&lt;Point1T&gt;::ConstPtr &amp; cloud_in,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">typename</span> pcl::PointCloud&lt;Point2T&gt;::ConstPtr &amp; cloud_ref,</span></span></span><br><span class="line"><span class="params"><span class="function">    Indices &amp; 											indices</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p>[input] cloud_in：待查询点云的引用</p>
<p>[input] cloud_ref：参考点云的引用</p>
<p>[output] indices：返回查询结果在参考点云中的索引向量</p>
<p><a target="_blank" rel="noopener" href="https://pcl.readthedocs.io/projects/tutorials/en/latest/kdtree_search.html#kdtree-search">代码示例</a> </p>
<p>运行输出：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-3-kd-tree%E6%A8%A1%E5%9D%97/1626165206589.png" alt="1626165206589"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/" class="post-title-link" itemprop="url">PCL学习(1):Ubuntu16.04无权限断网从源码安装PCL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-12 00:08:00" itemprop="dateCreated datePublished" datetime="2021-07-12T00:08:00+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-13 16:42:00" itemprop="dateModified" datetime="2021-07-13T16:42:00+08:00">2021-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>给Ubuntu装PCL是大二时候的事情了，那时候在自己电脑的双系统上装，root权限和网络都有，apt-get安装非常快。现在开始学PCL库，在实验室服务器上重新来装一遍，不同的是，这次既没有root权限也没有网页，就会麻烦很多，折腾了一天，记录一下。</p>
<h4 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h4><p>PCL需要的依赖库有点多，包括：</p>
<ul>
<li>必须：Boost，Eigen，FLANN，VTK</li>
<li>选择：Qhull，OpenNI，CUDA</li>
</ul>
<h4 id="apt-get安装"><a href="#apt-get安装" class="headerlink" title="apt-get安装"></a>apt-get安装</h4><p>如果有root权限不妨选择全部都装一遍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install git build-essential linux-libc-dev  </span><br><span class="line">sudo apt-get install cmake cmake-gui   </span><br><span class="line">sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev  </span><br><span class="line">sudo apt-get install mpi-default-dev openmpi-bin openmpi-common    </span><br><span class="line">sudo apt-get install libflann1.8 libflann-dev  </span><br><span class="line">sudo apt-get install libeigen3-dev  </span><br><span class="line">sudo apt-get install libboost-all-dev    </span><br><span class="line">sudo apt-get install libqhull* libgtest-dev  </span><br><span class="line">sudo apt-get install freeglut3-dev pkg-config  </span><br><span class="line">sudo apt-get install libxmu-dev libxi-dev   </span><br><span class="line">sudo apt-get install mono-complete  </span><br><span class="line">sudo apt-get install qt-sdk openjdk-8-jdk openjdk-8-jre</span><br></pre></td></tr></table></figure>
<p>关于Boost库的版本问题，由于我的系统是Ubuntu16.04，只支持到1.58，所以只能apt安装1.7版本的PCL；如果从源码安装更高版本的PCL则需要另外安装更高版本的Boost库。</p>
<p>接着：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libpcl-dev</span><br></pre></td></tr></table></figure>
<p>这样子PCL就安装完成啦！</p>
<h4 id="完全源码安装（包括各类依赖库）"><a href="#完全源码安装（包括各类依赖库）" class="headerlink" title="完全源码安装（包括各类依赖库）"></a>完全源码安装（包括各类依赖库）</h4><p>因为没有root权限，所以apt-get是用不了了，服务器没连网，所以git/wget也用不了，所有依赖库需要从 <a target="_blank" rel="noopener" href="https://packages.ubuntu.com/">Ubuntu Package</a> 网站上下载对应源码包，用ftp传到服务器上进行源码安装。比较麻烦，就只安装了必需的四个库。</p>
<p>需要注意的是，在编译安装前需要根据 Ubuntu Package 提供的依赖库进行检查，例如 libxt-dev 的依赖库有以下：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/1626051064861.png" alt="1626051064861"></p>
<p>使用 <code>dpkg -s 库名称</code> 检查服务器上是否已经安装过需要的依赖库，如果没有，就需要自己一个一个手动下载编译安装。如果嫌一个个检查麻烦的话，也可以直接安装四个依赖库，根据报错去补依赖库（没错就是我）。以openmpi为例介绍如何将依赖库安装到非root用户目录下。</p>
<p>首先开一个新的文件夹存放下载的源码文件（例如我的：<code>~/Download</code>），再开一个文件夹仿照 <code>/usr</code> 存放安装的各种头文件、链接库等等文件（例如我的：<code>~/Software</code>）。</p>
<p>主机下载完openmpi源码后ftp上传到服务器，会发现这一类源代码没有熟悉的CMakeLists而是直接的Makefile。</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/1626052217765.png" alt="1626052217765"></p>
<p>根据我们之前设置的安装路径进行config：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prerfix=/home/panweihong/Software</span><br></pre></td></tr></table></figure>
<p>这里的prefix就是将来这个库会被安装在哪个目录底下，默认是 <code>/usr</code> ，显然我们没有操作 <code>/usr</code> 目录的权限，所以需要把它改成我们自己的安装目录，并且需要特别注意的是，这里写的必须是绝对路径，像 <code>~/Software</code> 这样子是不行的。</p>
<p>config没有问题后就可以开始编译安装了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 &amp;&amp; make install -j8</span><br></pre></td></tr></table></figure>
<p>能开多核就开多核，速度能提快不止一点点。没有报错就okk；有报错大概率就是依赖库的问题，检查一下缺了什么库，再针对性地安装即可，安装过程和这个一模一样。</p>
<p>不过这样还没有完全结束，因为是手动安装，所以也需要手动配置路径。打开 <code>~/.bashrc</code> 文件，添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/你的安装目录/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=/你的安装目录/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> INCLUDE=/你的安装目录/include:<span class="variable">$INCLUDE</span></span><br><span class="line"><span class="built_in">export</span> PATH=/你的安装目录/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/你的安装目录/lib/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line"><span class="built_in">export</span> MANPATH=/你的安装目录/man:<span class="variable">$MANPATH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LD_LIBRARY_PATH：加载运行期间查找<strong>动态链接库</strong>的路径</li>
<li>LIBRARY_PATH：编译期间查找<strong>动态链接库</strong>的路径</li>
<li>INCLUDE：<strong>头文件</strong>路径</li>
<li>PATH：<strong>可执行文件</strong>路径</li>
<li>PKG_CONFIG_PATH：让安装库能找到依赖库的<strong>安装目录</strong></li>
<li><code>$VAR</code> ：表示引用 <code>VAR</code> 这个变量的值</li>
</ul>
<p>各路径由 <code>:</code> 隔开，设置好后退出 <code>~/.bashrc</code> 并 <code>source ~/.bashrc</code> 后，在终端执行 <code>echo $某个变量名</code> 检查是否生效。</p>
<p>另外一个小问题，因为每次 <code>source ~/.bashrc</code> 后文件中的 <code>export</code> 语句都会被执行一次，导致路径中有很多重复值，我的解决方法比较笨。就是在第一次export自己的路径前先echo一下这个变量原来的默认值，然后直接复制到原来 <code>$变量</code> 的位置，这样就不会因为重复export重复引用路径导致出现很多重复值了，这么做的原因是每次source的时候都会在第一个export给这个变量重新赋值，之后再有export就不会重复之前的值了，所以，后面再次export这个变量就和之前一样写 <code>$变量明</code> 就行了。</p>
<h5 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h5><p>本来boost库服务器上已经安装好了，我之所以重新安装，是因为最后编译PCL库的时候报了这个错：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/1626054896351.png" alt="1626054896351"></p>
<p>这两个库其实都是有的，用 <code>locate</code> 命令都能找得到，但就是多了个后缀：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/libboost_system.so.1.65.1</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libboost_iostreams.so.1.65.1</span><br></pre></td></tr></table></figure>
<p>本来是一个建立软链接就能解决的小事：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/x86_64-linux-gnu/</span><br><span class="line">sudo ln -s libboost_system.so.1.58.0  libboost_system.so</span><br><span class="line">sudo ln -s libboost_iostreams.so.1.58.0  libboost_iostreams.so </span><br></pre></td></tr></table></figure>
<p>但尴尬的是，没有权限啊！！！所以只能自己重新安装了Orz</p>
<p>先去 <a target="_blank" rel="noopener" href="http://sourceforge.net/projects/boost/files/boost">sourceforge</a> 下载自己需要版本的boost源码，在解压文件夹下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh --prefix=/home/panweihong/Software</span><br><span class="line">./b2 install --with=all</span><br></pre></td></tr></table></figure>
<p>如果系统中已经有了预装的boost，为了让自己的boost库能被找到，在cmake的时候加上编译条件 <code>-DBOOST_ROOT=/你的安装目录</code> ，例如我就是 <code>-DBOOST_ROOT=/home/panweihong/Software</code> </p>
<h5 id="Eigen3"><a href="#Eigen3" class="headerlink" title="Eigen3"></a>Eigen3</h5><p>先去 <a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen官网</a> 下载自己需要版本的Eigen源码，在解压文件夹下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=你的安装路径 ..</span><br><span class="line">make install -j8</span><br></pre></td></tr></table></figure>
<h5 id="FLANN"><a href="#FLANN" class="headerlink" title="FLANN"></a>FLANN</h5><p>同样先下载 <a target="_blank" rel="noopener" href="https://github.com/flann-lib/flann/releases">FLANN源码</a> ，在解压文件夹下执行与Eigen3安装相同的操作。</p>
<p>我遇到了一个非常神奇的问题，在用 3.15版本的cmake编译时，出现了这样的错误：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/1626054570126.png" alt="1626054570126"></p>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/flann-lib/flann/issues/369">这个解决方法</a> ，我重装了一个 3.10版本的cmake（从<a target="_blank" rel="noopener" href="https://cmake.org/files">这里</a>下源码，tar.gz文件不用安装，解压后直接添加环境变量就能用），再次编译就没有这个问题了（震惊.jpg）</p>
<h5 id="VTK"><a href="#VTK" class="headerlink" title="VTK"></a>VTK</h5><p>这是折腾了我最久的依赖库Orz</p>
<p>首先下载需要的源码文件：<a target="_blank" rel="noopener" href="https://www.vtk.org/files/release/8.2/VTK-8.2.0.tar.gz">VTK-8.2.0.tar.gz</a>和<a target="_blank" rel="noopener" href="https://www.vtk.org/files/release/8.2/VTKData-8.2.0.tar.gz">VTKData-8.2.0.tar.gz</a>，将VTKData解压到VTK文件下，执行与Eigen3安装类似的操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/home/panweihong/Software -DBUILD_SHARED_LIBS=ON -DBUILD_TESTING=ON -DCMAKE_BUILD_TYPE=Release -DVTK_WRAP_PYTHON=ON ..</span><br><span class="line">make -j8</span><br><span class="line">make install -j8</span><br></pre></td></tr></table></figure>
<ul>
<li>缺少 <code>libxt-dev</code> </li>
</ul>
<p>cmake的时候报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X11_Xt_LIB could not be found. Required <span class="keyword">for</span> VTK X lib.</span><br></pre></td></tr></table></figure>
<p>这是缺少 <code>libxt_dev</code> ，去 Ubuntu Package 上下载源码包，又缺依赖 <code>libsm-dev</code> ，<code>libsm-dev</code> 又缺 <code>libice-dev</code> （禁止套娃）。都下载编译安装，方法和上面讲的openmpi一样。不过在make的时候报了这样一个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc: error: ./sepces: Is a directory</span><br></pre></td></tr></table></figure>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/raphlinus/pulldown-cmark/issues/122">这个解决方法</a>，<code>LD_LIBRARY</code>、<code>LPATH</code> 和 <code>GCC_EXEC_PREFIX</code> 不能以 <code>:</code> 开头或结尾，并且泵你在中间的任何地方包含 <code>::</code> ，而像这种方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> VAR=some/new/path:<span class="variable">$VAR</span></span><br></pre></td></tr></table></figure>
<p>就很容易导致上述问题（当变量初始值为空时）。所以需要在 <code>~/.bashrc</code> 末尾添加一行用来删除路径中的空值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=$(<span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span> | sed -E -e <span class="string">&#x27;s/^:*//&#x27;</span> -e <span class="string">&#x27;s/:*$//&#x27;</span> -e <span class="string">&#x27;s/:+/:/g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>断网下载不了测试数据</li>
</ul>
<p>VTK在进行make的时候会下载一些测试数据到build的ExternalData文件夹下，但由于服务器断网，所以会出现 <code>(Couldn&#39;t connect to server)</code> 的问题。因为我在自己的双系统上安装过，所以还保留了下载完成的ExternalData文件夹，将该文件夹复制到build文件夹下，再执行make操作就不会报错了。这个数据文件我上传到<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1B46nLFuTDpMf9104N6SGQg">百度云</a>，提取码为64gw，我的VTK是8.2.0版本。</p>
<h5 id="PCL"><a href="#PCL" class="headerlink" title="PCL"></a>PCL</h5><p>下载<a target="_blank" rel="noopener" href="https://github.com/PointCloudLibrary/pcl/releases">源码文件</a> ，在解压文件夹下执行类似操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/home/panweihong/Software -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make -j8</span><br><span class="line">make install -j8</span><br></pre></td></tr></table></figure>
<h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4><p>从官网上拷贝了一份代码下来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pcl-1.7/pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pcl-1.7/pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pcl-1.7/pcl/point_types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;    </span><br><span class="line"></span><br><span class="line">    cloud.width = <span class="number">5</span>;</span><br><span class="line">    cloud.height = <span class="number">1</span>;</span><br><span class="line">    cloud.is_dense = <span class="literal">false</span>;</span><br><span class="line">    cloud.points.<span class="built_in">resize</span>(cloud.width*cloud.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">    &#123;</span><br><span class="line">        point.x = <span class="number">1024</span> * <span class="built_in">rand</span>() / (RAND_MAX+<span class="number">1.0f</span>);</span><br><span class="line">        point.y = <span class="number">1024</span> * <span class="built_in">rand</span>() / (RAND_MAX+<span class="number">1.0f</span>);</span><br><span class="line">        point.z = <span class="number">1024</span> * <span class="built_in">rand</span>() / (RAND_MAX+<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileASCII</span>(<span class="string">&quot;test_pcd.pcd&quot;</span>,cloud);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Saved &quot;</span> &lt;&lt; cloud.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data points to test_pcd.pcd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point.z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(PCL_LEARNING)</span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;EIGEN3_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;EIGEN3_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(PCL REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PCL_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PCL_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;PCL_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(pcd_write_test</span><br><span class="line">    pcd_write.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    pcd_write_test </span><br><span class="line">    <span class="variable">$&#123;PCL_LIBRARIES&#125;</span></span><br><span class="line">    <span class="variable">$&#123;EIGEN3_LIBS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果和我一样在vscode里跑的话，在c_cpp_properties.json文件中的<code>includePath</code>加入PCL和Eigen3（如果需要）的头文件路径后就不会报头文件找不到的错误了</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;/home/panweihong/Software/include/pcl-1.9&quot;</span>, </span><br><span class="line"><span class="string">&quot;/home/panweihong/Software/include/eigen3&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>./pcd_write_test</code> 输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Saved 5 data points to test_pcd.pcd</span><br><span class="line">   0.352222 -0.151883 -0.106395</span><br><span class="line">   -0.397406 -0.473106 0.292602</span><br><span class="line">   -0.731898 0.667105 0.441304</span><br><span class="line">   -0.734766 0.854581 -0.0361733</span><br><span class="line">   -0.4607 -0.277468 -0.916762</span><br></pre></td></tr></table></figure>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-1-Ubuntu16.04%E6%97%A0%E6%9D%83%E9%99%90%E6%96%AD%E7%BD%91%E4%BB%8E%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85PCL/1626058927783.png" alt="1626058927783"></p>
<p>成功输出就说明安装成功了！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/SLAM/PCL%E5%AD%A6%E4%B9%A0-2-IO%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/SLAM/PCL%E5%AD%A6%E4%B9%A0-2-IO%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">PCL学习(2):IO模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-12 00:08:00" itemprop="dateCreated datePublished" datetime="2021-07-12T00:08:00+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-13 16:42:26" itemprop="dateModified" datetime="2021-07-13T16:42:26+08:00">2021-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="OpenNI开源框架"><a href="#OpenNI开源框架" class="headerlink" title="OpenNI开源框架"></a>OpenNI开源框架</h4><p>OpenNI是一个多语言、跨平台的框架，主要目的是形成标准的、用于&lt;视音频传感器&gt;和&lt;视音频感知中间件&gt;间通信的API，兼容设备包括Primesense Reference Design、Microsoft Kinect 和 Asus XtionPro三种摄像头设备</p>
<h4 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I/O模块"></a>I/O模块</h4><p>包括有21个类和28个函数，实现对点云的获取、读入、存储等操作，既可通过点云文件进行输入输出，也可以通过封装借口直接从兼容设备获取源数据（包括RGB图像、深度图像和红外图像）。依赖 <code>pcl_common</code> 和 <code>pcl_octree</code> 及 OpenNI 外部开发包。</p>
<h4 id="PCD（点云数据）文件格式"><a href="#PCD（点云数据）文件格式" class="headerlink" title="PCD（点云数据）文件格式"></a>PCD（点云数据）文件格式</h4><h5 id="文件头格式"><a href="#文件头格式" class="headerlink" title="文件头格式"></a>文件头格式</h5><p>每个PCD文件都有一个文件头用来声明文件中存储的点云数据的各项特性，文件头必须用ASCII码编码，从0.7版本开始文件头<strong>按顺序</strong>包含以下字段，各字段之间用换行隔开：</p>
<ul>
<li><p>VERSION：指定PCD文件版本</p>
</li>
<li><p>FIELDS：指定一个点可以有的每个维度和字段的名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIELDS x y z							# XYZ 坐标数据</span><br><span class="line">FIELDS x y z rgb						# XYZ + 颜色数据</span><br><span class="line">FIELDS x y z normal_x normal_y normal_z # XYZ + 表面法向量</span><br><span class="line">FIELDS j1 j2 j3							# moment invariants</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>SIZE：用字节数指定每个维度的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned char / char -&gt; 1 byte</span><br><span class="line">unsigned short / short -&gt; 2 bytes</span><br><span class="line">unsigned int / int / float -&gt; 4 bytes</span><br><span class="line">double -&gt; 8 bytes</span><br></pre></td></tr></table></figure>
</li>
<li><p>TYPE：用一个字符指定每个维度的类型</p>
<ul>
<li><code>I</code> ：表示有符号类型</li>
<li><code>U</code> ：表示无符号类型</li>
<li><code>F</code> ：表示浮点类型</li>
</ul>
</li>
<li><p>COUNT：指定每个维度包含的元素数目（实际上是在给每个点引入n维直方图描述符的方法）默认情况下所有维度数目为1</p>
</li>
<li><p>WIDTH：用点的数量表示点云数据集的宽度</p>
<ul>
<li>无序数据集：表示点云中点的总数</li>
<li>有序数据集：表示点云数据集的宽度（一行中点的个数）</li>
</ul>
</li>
<li><p>HEIGHT：用点的数量表示点云数据集的高度（用来检查一个点云数据集是否有序）</p>
<ul>
<li>无序数据集：固定为1</li>
<li>有序数据集：表示点云数据集的高度（行的总数）</li>
</ul>
</li>
<li><p>VIEWPOINT：指定数据集中点云的获取视点，视点信息被指定为 <code>平移（tx ty tz)</code> + <code>四元数（qw qx qy qz）</code>，默认值为 <code>VIEWPOINT 0 0 0 1 0 0 0</code></p>
</li>
<li><p>POINTS：指定点云中点的总数</p>
</li>
<li><p>DATA：指定存储点云数据的数据类型，包括ASCII码和二进制两种。DATA的下一个字节开始就被视为点云的数据部分</p>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># .PCD v.7 - Point CLoud Data file format</span><br><span class="line">VERSION .7</span><br><span class="line">FIELDS x y z rgb</span><br><span class="line">SIZE 4 4 4 4</span><br><span class="line">TYPE F F F F</span><br><span class="line">COUNT 1 1 1 1</span><br><span class="line">WDTH 213</span><br><span class="line">HEIGHT 1</span><br><span class="line">VIEWPOINT 0 0 0 1 0 0 0</span><br><span class="line">POINTS 213</span><br><span class="line">DATA ascii</span><br><span class="line">0.93773 0.33763 0 4.2108e+06</span><br><span class="line">0.90805 0.35641 0 4.2108e+06</span><br></pre></td></tr></table></figure>
<p>这是一个0.7版本的PCD文件，每个点都有一个三维坐标数据和一个rgb颜色数据，四个维度均以浮点4字节存储（即float类型变量）。点云数据集无序，共213个点，默认视角，数据以ASCII码格式存储。</p>
</li>
</ul>
<h4 id="IO常用操作"><a href="#IO常用操作" class="headerlink" title="IO常用操作"></a>IO常用操作</h4><h5 id="PCD文件读取"><a href="#PCD文件读取" class="headerlink" title="PCD文件读取"></a>PCD文件读取</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pcl::io::loadPCDFile&lt;PointT&gt; (</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;file_name, </span><br><span class="line">    pcl::PointCloud&lt;PointT&gt; &amp;cloud)</span><br></pre></td></tr></table></figure>
<p>返回-1表示读取失败</p>
<h5 id="PCD文件写入"><a href="#PCD文件写入" class="headerlink" title="PCD文件写入"></a>PCD文件写入</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>	pcl::io::<span class="built_in">savePCDFileASCII</span> (</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;file_name, </span><br><span class="line">    <span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud)</span><br><span class="line"><span class="keyword">int</span> pcl::io::<span class="built_in">savePCDFileBinary</span> (</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;file_name, </span><br><span class="line">    <span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud)</span><br></pre></td></tr></table></figure>
<h5 id="连接两个点云"><a href="#连接两个点云" class="headerlink" title="连接两个点云"></a>连接两个点云</h5><ul>
<li><p><strong>点连接</strong>：即将两个格式相同（包括字段类型和维度都要相同）的点云中的点合并。&lt;增加点数&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloud_c = cloud_a;</span><br><span class="line">cloud_c += cloud_b;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-2-IO%E6%A8%A1%E5%9D%97/PCL学习(2" alt="1626140895249">-IO模块/1626140895249.png)</p>
</li>
<li><p><strong>域（字段）连接</strong>：例如点云A为N个点的XYZ点（pcl::PointXYZ），点云B为N个点的法向量（pcl::Normal），那么将两个点云进行字段连接得到的点云C则为N个点的pcl::PointNormal类型。&lt;增加维度&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcl::concatenateFields</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> pcl::PointCloud&lt;PointIn1T&gt; &amp;cloud1_in, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> pcl::PointCloud&lt;PointIn2T&gt; &amp;cloud2_in, </span></span></span><br><span class="line"><span class="params"><span class="function">    pcl::PointCloud&lt;PointOutT&gt; &amp;cloud_out)</span></span></span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="built_in">concatenateFields</span>(cloud_a, n_cloud_b, p_n_cloud_c);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/SLAM/PCL%E5%AD%A6%E4%B9%A0-2-IO%E6%A8%A1%E5%9D%97/1626141295700.png" alt="1626141295700"></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/slam/Multiple-View-Geometry-Lecture-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/slam/Multiple-View-Geometry-Lecture-1/" class="post-title-link" itemprop="url">Multiple View Geometry - Lecture 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-17 12:39:02" itemprop="dateCreated datePublished" datetime="2021-06-17T12:39:02+08:00">2021-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-27 23:04:18" itemprop="dateModified" datetime="2021-06-27T23:04:18+08:00">2021-06-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/slam/" itemprop="url" rel="index"><span itemprop="name">slam</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter-1-Linear-Algebra"><a href="#Chapter-1-Linear-Algebra" class="headerlink" title="Chapter 1: Linear Algebra"></a>Chapter 1: Linear Algebra</h3><h4 id="Vector-Spaces-向量空间"><a href="#Vector-Spaces-向量空间" class="headerlink" title="Vector Spaces(向量空间)"></a>Vector Spaces(向量空间)</h4><ul>
<li>线性空间 / 域 $\mathbb{R}$ 上的向量空间</li>
</ul>
<p>域 $\mathbb{R}$ 上的集合 $\mathbb{V}$ 对向量加法(vector summation)和数乘(scalar multiplication)封闭</p>
<script type="math/tex; mode=display">
\begin{align}
+:\mathbb{V}\times\mathbb{V}\rightarrow\mathbb{V} \notag\\ 
\cdot:\mathbb{R}\times\mathbb{V}\rightarrow\mathbb{V} \notag
\end{align}</script><p>即：$\forall \boldsymbol{v_1},\boldsymbol{v_2}\in\mathbb{V},\forall \alpha,\beta\in\mathbb{R}, \alpha\boldsymbol{v_1}+\beta\boldsymbol{v_2}\in\mathbb{V}$ </p>
<p>加法和数乘具体定义和满足的条件见矩阵分析第一讲</p>
<ul>
<li>子空间</li>
</ul>
<p>$\mathbb{W}\subset\mathbb{V},\boldsymbol{0}\in\mathbb{W}$，且对加法和数乘封闭，则称 $\mathbb{W}$ 为向量空间 $\mathbb{V}$ 的子空间</p>
<ul>
<li>线性无关</li>
</ul>
<p>一组向量 $\mathbb{S}=\{\boldsymbol{v_1},…,\boldsymbol{v_k}\}\subset\mathbb{V}$ 的生成子空间定义为：</p>
<script type="math/tex; mode=display">
\text{span}(\mathbb{S})=\{\boldsymbol{v}\in\mathbb{V}|\boldsymbol{v}=\sum^k_{i=1}\alpha_i\boldsymbol{v_i}\}</script><p>集合 $\mathbb{S}$ 线性无关的条件：</p>
<script type="math/tex; mode=display">
\sum^k_{i=1}\alpha_i\boldsymbol{v_i}=0\Rightarrow\alpha_i=0\ \forall i</script><p>即集合中的所有向量都不能被其他向量所表示，反之则称该集合线性相关</p>
<ul>
<li>线性空间的一组基(basis)</li>
</ul>
<p>向量组 $\mathbb{B}=\{\boldsymbol{v_1},…\boldsymbol{v_n}\}$ 线性无关且生成子空间为 $\mathbb{V}$ ，则称向量组 $\mathbb{B}$ 为线性空间 $\mathbb{V}$ 的一组基，即线性无关向量的最大集合</p>
<p>若向量组 $\mathbb{B}$ 和 $\mathbb{B’}$ 是线性空间 $\mathbb{V}$ 的两组基，那么有以下三个结论</p>
<ol>
<li><p>$\mathbb{B}$ 和 $\mathbb{B’}$ 中的向量个数相等，均为 $n$ ，称为线性空间 $\mathbb{V}$ 的维度</p>
</li>
<li><p>$\forall \boldsymbol{v}\in\mathbb{V}$ 都可由向量组 $\mathbb{B}$ 中的基向量唯一线性表出</p>
</li>
<li><p>特殊地，向量组 $\mathbb{B’}$ 中的所有向量都可由 $\mathbb{B}$ 线性表出：</p>
<script type="math/tex; mode=display">
b'_i=\sum^n_{j=1}a_{ji}b_j</script><p>该基变换中的系数 $a_{ji}$ 组成矩阵 $\boldsymbol{A}$，$\boldsymbol{B}=[b_1,…b_n],\boldsymbol{B’}=[b_1’…,b_n’]$ ，故上式可写作：</p>
<script type="math/tex; mode=display">
\boldsymbol{B'}=\boldsymbol{BA}\Leftrightarrow\boldsymbol{B}=\boldsymbol{B'A^{-1}}</script></li>
</ol>
<ul>
<li><p>内积(Inner Product)</p>
<p>在向量空间中定义内积（点积）$\langle\cdot,\cdot\rangle:\mathbb{V}\times\mathbb{V}\rightarrow\mathbb{R}$ ，满足以下三个条件：</p>
<ol>
<li>线性性：$\langle\boldsymbol{u},\alpha\boldsymbol{v}+\beta\boldsymbol{w}\rangle=\alpha\langle\boldsymbol{u},\boldsymbol{v}\rangle+\beta\langle\boldsymbol{u},\boldsymbol{w}\rangle$ </li>
<li>对称性：$\langle\boldsymbol{u},\boldsymbol{v}\rangle=\langle\boldsymbol{v},\boldsymbol{u}\rangle$ </li>
<li>正定性：$\langle\boldsymbol{v},\boldsymbol{v}\rangle\geq0$ 且 $\langle\boldsymbol{v},\boldsymbol{v}\rangle=0\Leftrightarrow\boldsymbol{v}=\boldsymbol{0}$ </li>
</ol>
<p>从而定义了一个<strong>范数</strong>(norm) ：</p>
<script type="math/tex; mode=display">
|\cdot|:\mathbb{V}\rightarrow\mathbb{R},|\boldsymbol{v}|=\sqrt{\langle\boldsymbol{v},\boldsymbol{v}\rangle}</script><p>和一个<strong>度量</strong>(metric) ：</p>
<script type="math/tex; mode=display">
\text{d}:\mathbb{V}\times\mathbb{V}\rightarrow\mathbb{R},\text{d}(\boldsymbol{v},\boldsymbol{w})=|\boldsymbol{v}-\boldsymbol{w}|=\sqrt{\langle\boldsymbol{v}-\boldsymbol{w},\boldsymbol{v}-\boldsymbol{w}\rangle}</script><p>分别用来计算向量长度和向量间的距离，这使得 $\mathbb{V}$ 成为一个度量空间，又因为该度量是由向量内积定义的，所以又称 $\mathbb{V}$ 为<strong>希尔伯特空间(Hilbert Space)</strong> </p>
</li>
<li><p><strong>标准内积</strong>与生成内积(Canonical Inner Product and Induced Inner Product)</p>
<p>特殊地，在 $\mathbb{V}=\mathbb{R}$ 时，可以由标准基 $\boldsymbol{B}=\boldsymbol{I}_n$ (n维单位矩阵)定义标准内积：$\langle \boldsymbol{x},\boldsymbol{y}\rangle=\boldsymbol{x}^T\boldsymbol{y}=\sum^n_{i=1}x_iy_i$ ，从而定义出了标准 $L_2$ 范数（欧几里得范数）$|\boldsymbol{x}|=\sqrt{\boldsymbol{x}^T\boldsymbol{x}}=\sqrt{x_1^2+…+x_n^2}$ </p>
<p>对于一个新给出的基底 $\boldsymbol{B}’$ ，有基变换 $\boldsymbol{A}$ 使得 $\boldsymbol{I}=\boldsymbol{B}’\boldsymbol{A}^{-1}$ ，那么标准内积用新坐标 $\boldsymbol{x}’,\boldsymbol{y}’$ 可表示为：$\langle\boldsymbol{x},\boldsymbol{y}\rangle=\boldsymbol{x}^T\boldsymbol{y}=(\boldsymbol{Ax}’)^T(\boldsymbol{Ay}’)=\boldsymbol{x}’^T\boldsymbol{A}^T\boldsymbol{A}\boldsymbol{y}’\equiv\langle\boldsymbol{x}’,\boldsymbol{y}’\rangle_{\boldsymbol{A}^T\boldsymbol{A}}$ ，后者成为变换矩阵 $\boldsymbol{A}$ 下的<strong>生成内积</strong></p>
<p>当且仅当 $\langle\boldsymbol{v},\boldsymbol{w}\rangle=0$ 时向量正交</p>
</li>
<li><p>(<font color="red">新概念</font>)  矩阵的 <strong>Kronecker积</strong> 和 <strong>Stack</strong>（堆）</p>
<p>给定两个任意大小的矩阵 $\boldsymbol{A}\in\mathbb{R}^{m\times n}$ 和 $\boldsymbol{B}\in\mathbb{R}^{k\times l}$ ，定义它们的 <font color="green">Kronecker积</font> 如下： </p>
<script type="math/tex; mode=display">
\boldsymbol{A}\otimes\boldsymbol{B}\equiv
\left(
\begin{matrix}
a_{11}\boldsymbol{B} \  \cdots \  a_{1n}\boldsymbol{B}\\
\vdots \quad \ddots \quad \vdots \\
a_{m1}\boldsymbol{B} \  \cdots \  a_{mn}\boldsymbol{B}
\end{matrix}
\right)
\in\mathbb{R}^{mk\times nl}.</script><p>矩阵 $\boldsymbol{A}$ 的 <font color="green">Stack</font> (堆) $\boldsymbol{A}^s$ 则定义为一个由所有n个列向量纵向堆叠而成的的列向量：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}^s\equiv
\left(
\begin{matrix}
\boldsymbol{a_1}\\
\vdots \\
\boldsymbol{a_n}
\end{matrix}
\right)\in\mathbb{R}^{mn}.</script><p>上述定义使得代数表达式可以被重写得更加直观，例如：</p>
<script type="math/tex; mode=display">
\boldsymbol{u}^T\boldsymbol{A}\boldsymbol{v}=(\boldsymbol{v}\otimes\boldsymbol{u})^T\boldsymbol{A}^s</script><p>这其实是容易证明的：</p>
<script type="math/tex; mode=display">
\begin{align}
\boldsymbol{u}^T\boldsymbol{A}\boldsymbol{v}
&=(\quad\quad)_{1\times m}\left(\begin{matrix}\quad\quad\\ \\ \end{matrix}\right)_{m\times n}\left(\begin{matrix}\\ \\\end{matrix}\right)_{n\times1} \notag\\
&=\left(\boldsymbol{u}^T\boldsymbol{a_1}\ ...\ \boldsymbol{u}^T\boldsymbol{a_n}\right)_{1\times n}\left(\begin{matrix}\\\\\end{matrix}\right)_{n\times1} \notag \\
&=\boldsymbol{u}^T\boldsymbol{a_1}v_1+...+\boldsymbol{u}^T\boldsymbol{a_n}v_n \notag \\
&=\boldsymbol{u}^Tv_1\cdot\boldsymbol{a_1}+...+\boldsymbol{u}^Tv_n\cdot\boldsymbol{a_n} \notag \\
&=\left(\boldsymbol{u}^Tv_1\ ...\ \boldsymbol{u}^Tv_n\right)\left(\begin{matrix}\boldsymbol{a_1}\\\vdots\\\boldsymbol{a_n}\end{matrix}\right) \notag \\
&=\left(\begin{matrix}v_1\boldsymbol{u}\\\vdots\\v_n\boldsymbol{u}\end{matrix}\right)^T\left(\begin{matrix}\boldsymbol{a_1}\\\vdots\\\boldsymbol{a_n}\end{matrix}\right) \notag \\
&=(\boldsymbol{v}\otimes\boldsymbol{u})^T\boldsymbol{A}^s \notag

\end{align}</script></li>
</ul>
<h4 id="Linear-Transformations-and-Matrices-线性变换和矩阵"><a href="#Linear-Transformations-and-Matrices-线性变换和矩阵" class="headerlink" title="Linear Transformations and Matrices(线性变换和矩阵)"></a>Linear Transformations and Matrices(线性变换和矩阵)</h4><p>线性代数研究的是两个线性空间之间的线性变换，由于这些线性变换都可以用矩阵表示，所以线性代数相当于在研究矩阵的特性。</p>
<p>两个线性空间 $\mathbb{V}$ 和 $\mathbb{W}$ 之间的 <font color="green"><strong>线性变换(Linear Transformation)</strong></font> 是一个映射 $\boldsymbol{L}: \mathbb{V}\rightarrow\mathbb{W}$ ，它满足以下两个条件：</p>
<ol>
<li>$\boldsymbol{L}(\boldsymbol{x}+\boldsymbol{y})=\boldsymbol{L}(\boldsymbol{x})+\boldsymbol{L}(\boldsymbol{y})\quad\forall\boldsymbol{x},\boldsymbol{y}\in\mathbb{V}$ </li>
<li>$\boldsymbol{L}(\alpha\boldsymbol{x})=\alpha\boldsymbol{L}(\boldsymbol{x})\quad \forall\boldsymbol{x}\in\mathbb{V},\alpha\in\mathbb{R}$ </li>
</ol>
<p>由于线性性，线性变换 $\boldsymbol{L}$ 对空间 $\mathbb{V}$ 的操作可以唯一定义为对 $\mathbb{V}$ 上基向量的操作，对标准基 $\{\boldsymbol{\theta_1},…,\boldsymbol{\theta_n}\}$ 有：$\boldsymbol{L}(\boldsymbol{x})=\boldsymbol{Ax}\quad \forall\boldsymbol{x}\in\mathbb{V}$ 其中 $\boldsymbol{A}=(\boldsymbol{L}(\boldsymbol{\theta_1}),…,\boldsymbol{L}(\boldsymbol{\theta_n}))\in\mathbb{R}^{m\times n}$ </p>
<p>所有 $m\times n$ 维实矩阵组成的集合记为 $\mathcal{M}(m,n)$ ，当 $m=n$ 时，集合 $\mathcal{M}(m,n)\equiv\mathcal{M}(n)$ 就形成了域 $\mathbb{R}$ 上的一个 <font color="green">环</font>，即满足对矩阵乘法和矩阵加法封闭</p>
<ul>
<li><p><font color="red"><strong>线性群</strong></font> $GL(n)$ 和 $SL(n)$</p>
<p><font color="green"><strong>群</strong></font> 的概念：集合 $\mathbb{G}$ 与集合 $\mathbb{G}$ 上定义的一种运算：$\circ :\mathbb{G}\times\mathbb{G}\rightarrow\mathbb{G}$ 满足以下四个条件：</p>
<ol>
<li>封闭性：$\boldsymbol{g}_1\circ\boldsymbol{g}_2\in\mathbb{G},\quad\forall\boldsymbol{g}_1,\boldsymbol{g}_2\in\mathbb{G}$ </li>
<li>结合律：$(\boldsymbol{g}_1\circ\boldsymbol{g}_2)\circ\boldsymbol{g}_3=\boldsymbol{g}_1\circ(\boldsymbol{g}_2\circ\boldsymbol{g}_3),\quad\forall\boldsymbol{g}_1,\boldsymbol{g}_2,\boldsymbol{g}_3\in\mathbb{G}$ </li>
<li>幺元：$\exists\boldsymbol{e}\in\mathbb{G},\ s.t.\ \boldsymbol{e}\circ\boldsymbol{g}=\boldsymbol{g}\circ\boldsymbol{e}=\boldsymbol{g},\quad \forall\boldsymbol{g}\in\mathbb{G}$ </li>
<li>可逆性：$\exists\boldsymbol{g}^{-1}\in\mathbb{G},\ s.t.\ \boldsymbol{g}\circ\boldsymbol{g}^{-1}=\boldsymbol{g}^{-1}\boldsymbol{g}=\boldsymbol{e},\quad\forall\boldsymbol{g}\in\mathbb{G}$</li>
</ol>
<p>这样的集合就称为<strong>群</strong> 。</p>
<ul>
<li>所有<strong>可逆</strong>（非奇异）$n\times n$ 维实矩阵和矩阵乘法就构成了一个群，这个群称为 <font color="green"><strong>general linear group</strong></font>，记作 $GL(n)$ ，该群中包含了所有行列式非零的 $n\times n$ 维<strong>方阵</strong>；</li>
<li>进一步，$GL(n)$ 中所有<strong>行列式为1</strong>的矩阵又组成了一个群，称为 <font color="green"><strong>special linear group</strong></font> ，记作 $SL(n)$ ，根据可逆性，该群中的方阵满足：$\text{det}(\boldsymbol{A}^{-1})=\text{det}(\boldsymbol{A})^{-1}$ </li>
</ul>
</li>
<li><font color="red">**群的矩阵表示**</font> 

<p>一个群 $G$ 有矩阵表示（可被视为矩阵群）的条件：</p>
<ul>
<li>存在一个群的同构映射（群同态）$R:G\rightarrow GL(n)$ .</li>
</ul>
<p>该映射保留了群 $G$ 的群结构，即保留了幺元、群乘、可逆性等：</p>
<script type="math/tex; mode=display">
\begin{align}
&R(e)=I_{n\times n} \notag \\
&R(g\circ h)=R(g)R(h),\ \ \forall g,h\in G \notag \\
&\text{if}\ \ g\circ g^{-1}=g^{-1}\circ g=e,\ \ \text{then}\ \ R(g)R(g^{-1})=I_{n\times n} \notag
\end{align}</script><p>之所以引进群的矩阵表示，是因为这能实现从研究矩阵群的特征角度来研究更抽象的群。</p>
<p>例如：物体旋转运动构成了一个群，如果能用矩阵表示旋转，那么研究旋转群的特征会容易很多</p>
</li>
<li><p>仿射群 $A(n)$ </p>
<p>仿射变换 $L:\mathbb{R}^n\rightarrow \mathbb{R}^n$ 可以由一个矩阵 $\boldsymbol{A}\in GL(n)$ 和一个向量 $\boldsymbol{b}\in \mathbb{R}^n$ 唯一定义 ：</p>
<script type="math/tex; mode=display">
L(\boldsymbol{x})=\boldsymbol{Ax+b}</script><p>由这些仿射变换构成的集合称为<font color="green"> <strong>$n$ 维仿射群</strong> </font>，记作 $A(n)$ </p>
<p>显然，上述定义的仿射变换 $L$ 不是个线性映射，除非 $\boldsymbol{b}=\boldsymbol{0}$。通过引入<font color="green"> <strong>齐次坐标</strong> </font>（将 $\boldsymbol{x}\in\mathbb{R}^n$ 表示为 $\left(\begin{matrix}\boldsymbol{x}\\1\end{matrix}\right)\in\mathbb{R}^{n+1}$ ）可以把 $L:\mathbb{R}^n\rightarrow \mathbb{R}^n$ 变成一个线性映射 $L:\mathbb{R}^{n+1}\rightarrow \mathbb{R}^{n+1}$ ：</p>
<script type="math/tex; mode=display">
\left(
\begin{matrix}
\boldsymbol{x} \\ 1
\end{matrix}
\right)
\mapsto
\left(
\begin{matrix}
\boldsymbol{A} \quad \boldsymbol{b} \\
\boldsymbol{0} \quad\  1
\end{matrix}
\right)
\left(
\begin{matrix}
\boldsymbol{x} \\ 1
\end{matrix}
\right)</script><p>矩阵 $\left(<br>\begin{matrix}<br>\boldsymbol{A} \quad \boldsymbol{b} \\<br>\boldsymbol{0} \quad\  1<br>\end{matrix}<br>\right)\in GL(n+1)$ 称为<font color="green"> <strong>仿射矩阵</strong> </font>，所有仿射矩阵构成了 $GL(n+1)$ 的一个子群</p>
</li>
<li><p>正交群 $O(n)$</p>
<p>所有 $n\times n$ 的正交矩阵构成了正交群 $O(n)=\{\boldsymbol{R}\in GL(n)|\boldsymbol{R}^T\boldsymbol{R}=\boldsymbol{I}\}$ ，显然它是群 $GL(n)$ 的子群，且 $\text{det}(\boldsymbol{R}^T\boldsymbol{R})=(\text{det}(\boldsymbol{R}))^2=\text{det}(\boldsymbol{I})=1\Rightarrow\text{det}(\boldsymbol{R})\in\{+1,-1\}$ </p>
<p>将 $O(n)$ 满足 $\text{det}(\boldsymbol{R})=+1$ 的子群称为<font color="green"> <strong>特殊正交群</strong> </font>，记作 $SO(n)$ ，显然 $SO(n)=O(n)\cap SL(n)$ 。特别地，$SO(3)$ 即为三维旋转矩阵构成的群（行列式为-1的矩阵为镜像矩阵）</p>
</li>
<li><p>欧氏群 $E(n)$</p>
<p>由正交阵 $\boldsymbol{R}\in O(n)$ 和向量 $\boldsymbol{T}\in \mathbb{R}^n$ 定义出一个欧氏变换：$L:\mathbb{R}^n\rightarrow \mathbb{R}^n;\quad \boldsymbol{x}\mapsto\boldsymbol{Rx+T}$ </p>
<p>由这种变换组成的集合称为欧几里得群（欧氏群）$E(n)$ ，显然它是仿射群 $A(n)$ 的子群，基于齐次坐标，欧氏群的矩阵表示如下：</p>
<script type="math/tex; mode=display">
E(n)=\left\{ 
\left(
\begin{matrix}
\boldsymbol{R} \quad\boldsymbol{T}\\
\boldsymbol{0} \quad\ 1
\end{matrix}
\right)\Bigg|
\boldsymbol{R}\in O(n),\boldsymbol{T}\in\mathbb{R}^n
\right\}</script><p>对应地，若 $\boldsymbol{R}\in SO(n)$ ，那么此时的欧氏群称作<font color="green"> <strong>特殊欧氏群</strong> </font>，记作 $SE(n)$ 。特别地，$SE(3)$ 表示的是三维刚体运动。</p>
<p>综上，几个群之间的关系有：</p>
<script type="math/tex; mode=display">
\boxed{SO(n)\subset O{n}\subset GL(n),\quad SE(n)\subset E(n)\subset A(n)\subset GL(n+1)}</script></li>
</ul>
<h4 id="Properties-of-Matrices-矩阵特征"><a href="#Properties-of-Matrices-矩阵特征" class="headerlink" title="Properties of Matrices(矩阵特征)"></a>Properties of Matrices(矩阵特征)</h4><h4 id="SVD-Singular-Value-Decomposition"><a href="#SVD-Singular-Value-Decomposition" class="headerlink" title="SVD(Singular Value Decomposition)"></a>SVD(Singular Value Decomposition)</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E8%AE%B2-%E5%86%85%E7%A7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E8%AE%B2-%E5%86%85%E7%A7%AF/" class="post-title-link" itemprop="url">矩阵分析学习笔记3：内积</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 00:03:41" itemprop="dateCreated datePublished" datetime="2021-05-30T00:03:41+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-13 22:28:26" itemprop="dateModified" datetime="2021-07-13T22:28:26+08:00">2021-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">矩阵分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter3-内积"><a href="#Chapter3-内积" class="headerlink" title="Chapter3 内积"></a>Chapter3 内积</h3><h4 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h4><p>设 $\mathbb{V}$ 是 $\mathbb{R}$ 上的一个线性空间，定义映射 $\tau: \mathbb{V}\times\mathbb{V}\rightarrow\mathbb{R}$ 。称映射 $\tau$ 为 $\mathbb{V}$ 上的一个内积，且记 $\tau(v_1,v_2)=<v_1,v_2>$ ，该映射需满足以下<strong>三个条件</strong>：</v_1,v_2></p>
<p>(1) 对称性:  $<v_1,v_2>=<v_2, v_1>$ </v_2,></v_1,v_2></p>
<p>(2) 固定第一个变元，对第二个变元有线性性:  $<v_1,v_2k+v_3l>=<v_1,v_2>k+<v_1,v_3>l$ </v_1,v_3></v_1,v_2></v_1,v_2k+v_3l></p>
<p>(3) 正定性: 对 $\forall v\neq0,<v,v>&gt;0$ </v,v></p>
<p>定义了内积的线性空间称为内积空间，有限维的内积空间称为<strong>欧几里得空间</strong>（有限维内积空间）</p>
<p>内积有如下<strong>性质</strong>：</p>
<p>(1) $&lt;\boldsymbol{0},\boldsymbol{v}&gt;=0$ </p>
<p>(2) 双线性：固定第二个变元，对第一个变元也满足线性性</p>
<ul>
<li>$\mathbb{R}^n$ 上的标准内积 </li>
</ul>
<p>定义映射 $\tau: \mathbb{R}^n\times\mathbb{R}^n\rightarrow\mathbb{R}$ ，满足 $&lt;\boldsymbol{x},\boldsymbol{y}&gt;=\boldsymbol{x}^T\boldsymbol{y}=x_1y_1+x_2y_2+…+x_ny_n$ ，称 $\tau$ 为 $\mathbb{R}^n$ 上的标准内积</p>
<p>​        </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/" class="post-title-link" itemprop="url">矩阵分析学习笔记2：多项式矩阵与Jordan标准型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-28 13:30:03" itemprop="dateCreated datePublished" datetime="2021-05-28T13:30:03+08:00">2021-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-29 08:47:15" itemprop="dateModified" datetime="2021-05-29T08:47:15+08:00">2021-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">矩阵分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter2-lambda-矩阵与Jordan标准型"><a href="#Chapter2-lambda-矩阵与Jordan标准型" class="headerlink" title="Chapter2 $\lambda$ 矩阵与Jordan标准型"></a>Chapter2 $\lambda$ 矩阵与Jordan标准型</h3><p>为了解决数域矩阵相似最简型的问题，我们引入 $\lambda$ 矩阵</p>
<h4 id="lambda-矩阵及其Smith型"><a href="#lambda-矩阵及其Smith型" class="headerlink" title="$\lambda$ 矩阵及其Smith型"></a>$\lambda$ 矩阵及其Smith型</h4><h5 id="lambda-矩阵"><a href="#lambda-矩阵" class="headerlink" title="$\lambda$ 矩阵"></a>$\lambda$ 矩阵</h5><p>以多项式为元素的矩阵</p>
<ul>
<li>$\mathbb{F}[\lambda]$ ：表示以数域 $\mathbb{F}$ 中的元素为系数的多项式集合</li>
<li>$(\mathbb{F}[\lambda])^{m\times n}=\{[a_{ij}(\lambda)]_{m\times n}|a_{ij}(\lambda)\in \mathbb{F}[\lambda]\}$ （类比 $\mathbb{F}^{m\times n}$） </li>
<li>$\lambda$ 矩阵： $\boldsymbol{A}(\lambda)=[a_{ij}(\lambda)]_{m\times n},\ a_{ij}(\lambda)\in\mathbb{F}[\lambda],\ \boldsymbol{A}(\lambda)\in(\mathbb{F}[\lambda])^{m\times n}$  </li>
<li>从映射观点看 $\lambda$ 矩阵：$\mathbb{F}\rightarrow\mathbb{F}^{m\times n},\ \lambda\mapsto\boldsymbol{A}(\lambda)$ </li>
<li>从矩阵多项式观点看 $\lambda$ 矩阵：$\boldsymbol{A}(\lambda) = A_0+A_1\lambda+A_2\lambda^2+\cdots+$ ，即以矩阵为系数的多项式</li>
</ul>
<p>$\lambda$ 矩阵的秩</p>
<ul>
<li>不为<strong>零多项式</strong>的子式的最大阶数 （以多项式为元素算行列式）</li>
</ul>
<h5 id="单位模阵（幺模阵）"><a href="#单位模阵（幺模阵）" class="headerlink" title="单位模阵（幺模阵）"></a>单位模阵（幺模阵）</h5><ul>
<li>对 $\boldsymbol{U}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n}$ ，若 $\exists\ \boldsymbol{V}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n},\ s.t.\ \boldsymbol{U}(\lambda)\boldsymbol{V}(\lambda)=\boldsymbol{V}(\lambda)\boldsymbol{U}(\lambda)=\boldsymbol{I}_n$ ，则称 $\boldsymbol{V}(\lambda)$ 为 $\boldsymbol{U}(\lambda)$ 的单位模阵。</li>
</ul>
<p>单位模阵：逆矩阵，且必须是多项式矩阵，因为单纯逆矩阵 $\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^*$ 不一定是多项式矩阵</p>
<p>多项式矩阵相对于前面所谈论的数值矩阵，主要不同就在于除法运算上，即多项式相除结果不一定还是多项式。用抽象数学的概念，数值矩阵谈论是<strong>域</strong>上的矩阵，而多项式矩阵谈论的是<strong>环</strong>上的矩阵</p>
<ul>
<li>$\boldsymbol{U}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n}$ 为单位模阵 $\Leftrightarrow |\boldsymbol{U}(\lambda)|$ 是非零常值多项式（即 $a_0\neq 0$ 的零次多项式）</li>
</ul>
<p>下面给出证明：</p>
<p>$\Leftarrow$ ：显然</p>
<p>$\Rightarrow$ ：存在多项式矩阵 $\boldsymbol{V}(\lambda)$ ，使得 $\boldsymbol{U}(\lambda)\boldsymbol{V}(\lambda)=\boldsymbol{I}_n\Rightarrow|\boldsymbol{U}(\lambda)||\boldsymbol{V}(\lambda)|=1\Rightarrow f(\lambda)g(\lambda)=1$ ，两个多项式相乘等于1，这两个多项式只能是 $a_0\neq 0$ 的零次多项式，否则相乘一定有变量在 </p>
<h5 id="lambda-矩阵的初等行（列）变换"><a href="#lambda-矩阵的初等行（列）变换" class="headerlink" title="$\lambda$ 矩阵的初等行（列）变换"></a>$\lambda$ 矩阵的初等行（列）变换</h5><p>以初等行变换为例 $\Leftrightarrow$ 左乘一个相应的初等矩阵：</p>
<ul>
<li><p>某两行互换 $\Leftrightarrow$ eg. $\begin{bmatrix} 0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
</li>
<li><p><strong>某行乘以非零常数</strong> $\Leftrightarrow$ eg. $\begin{bmatrix} c&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
<p>注：不是乘以非零多项式！因为乘以多项式是不可逆的，即对应乘上的矩阵没有单位模阵</p>
</li>
<li><p>某行乘以一个多项式再加到另一行上 $\Leftrightarrow$ eg. $\begin{bmatrix}1&amp;0&amp;0\\f(\lambda)&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
</li>
</ul>
<h5 id="lambda-矩阵经左右初等变换化简"><a href="#lambda-矩阵经左右初等变换化简" class="headerlink" title="$\lambda$ 矩阵经左右初等变换化简"></a>$\lambda$ 矩阵经左右初等变换化简</h5><ul>
<li><p>$\lambda$ 矩阵的等价：经初等行列变换可以互相转化的两个 $\lambda$ 矩阵等价，记作 $\boldsymbol{A}(\lambda) \sim \boldsymbol{B}(\lambda) $ </p>
</li>
<li><p>【用初等行变换为矩阵左上角降次】设 $\boldsymbol{A}(\lambda) =[a_{ij}(\lambda)]_{m\times n},\ a_{11}(\lambda)\neq0$ ， 且至少有一个元素不能被 $a_{11}(\lambda)$ 整除（$\Leftrightarrow a_{11}(\lambda)$ 不为非零常值多项式 ），则有 $\boldsymbol{A}(\lambda) \sim\boldsymbol{B}(\lambda) $ 且 $b_{11}(\lambda)\neq0,\ \partial(b_{11}(\lambda))&lt;\partial(a_{11}(\lambda))$ （$\partial(多项式)$ 表示该多项式的次数）</p>
<p>下面给出证明概要：</p>
<ul>
<li><p>同行中有一个元素 $a_{1j}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除，即 $a_{1j}(\lambda)=a_{11}(\lambda)q(\lambda)+r(\lambda),\ 且\ \partial(r(\lambda))&lt;\partial(a(\lambda))$ ，所以，将第一列乘以 $-q(\lambda)$ 加到第 $j$ 列后交换第一列与第 $j$ 列，此时 $a_{11}(\lambda)’=r(\lambda),\partial(a_{11}(\lambda)’)&lt;\partial(a_{11}(\lambda))$ ，从而实现降次</p>
</li>
<li><p>同列中有一个元素 $a_{i1}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除，同理</p>
</li>
<li><p>同行同列都能被整除，但有 $a_{ij}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除。</p>
<p>首先可以通过一系列行列变换把第一列、第一行除了 $a_{11}(\lambda)$ 外都化为0，同时保证变换后的 $a_{ij}(\lambda)’$ 仍旧不能被 $a_{11}(\lambda)$ 整除（不能被整除的数加上除数的倍数依然不能被整除），将变换后的第 $j$ 行加到第1行，就回到第一种情况了</p>
</li>
</ul>
</li>
</ul>
<h5 id="Smith-型-lambda-矩阵"><a href="#Smith-型-lambda-矩阵" class="headerlink" title="Smith 型 $\lambda$ 矩阵"></a>Smith 型 $\lambda$ 矩阵</h5><p>设：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}(\lambda)\sim \boldsymbol{B}(\lambda)=
\left[
\begin{array}{ccc|ccc}
    d_1({\lambda}) & & & 0 & \cdots & 0\\
    & \ddots & &\vdots &\ddots &\vdots \\
    & & d_r(\lambda) &0 &\cdots &0 \\
    \hline 
    0 & \cdots & 0 &0 &\cdots &0 \\
    \vdots &\ddots &\vdots &\vdots &\ddots &\vdots \\
    0 & \cdots & 0 &0 &\cdots &0
\end{array}
\right]</script><p>其中 $r=\text{rank}(\boldsymbol{A}(\lambda))$ ，$d_i(\lambda)$ 为非零多项式，且 $d_i(\lambda)|d_{i+1}(\lambda)$ （$f(\lambda)|g(\lambda)$ 表示 $f$ 整除 $g$ ），则称 $\boldsymbol{B}(\lambda)$ 为 $\boldsymbol{A}(\lambda)$ 的 <code>Smith标准型</code> 。</p>
<p>下面给出证明：</p>
<ul>
<li><p>存在性</p>
<p>若为零矩阵，则显然；若为非零矩阵，必存在非零多项式，通过行列变换将次数最低的非零多项式移到 $a_{11}(\lambda)$ ，会出现以下两种情况：</p>
<ul>
<li>矩阵中所有元素都能被 $a_{11}(\lambda)$ 整除</li>
<li>存在若干元素不能被 $a_{11}(\lambda)$ 整除</li>
</ul>
<p>对于第二种情况，【用初等行变换为左上角降次】，降次必然是有限的，不能再降次的时候，也就是矩阵中的所有元素都能被 $a_{11}(\lambda)$ 整除的时候 ，进而同行同列的元素都能化成0</p>
<p>对右下子矩阵进行相同的操作，以此类推，最终得到 <code>Smith标准型</code> </p>
</li>
<li><p>唯一性</p>
<p>约定 $d_i(\lambda)$ 都是首1多项式，即最高次数系数为1</p>
<ul>
<li><p><strong>$\lambda$ 矩阵的 $k$ 阶行列式因子</strong> ：$\boldsymbol{A}(\lambda)$ 的所有 $k$ 阶子式的最高公因式</p>
</li>
<li><p><strong>初等变换不改变 $k$ 阶行列式因子</strong> </p>
<p>下面给出证明：</p>
<p>设 $\mathscr{A}=\{\boldsymbol{A}\ 的\ k\ 阶子式\},\mathscr{B}=\{\boldsymbol{B}\ 的\ k\ 阶子式\}$ ，只需证 $\mathscr{A},\mathscr{B}$ 的最高公因式相同。</p>
<p>任取 $f(\lambda)\in\mathscr{B}$ ，考察它与 $\mathscr{A}$ 中多项式的关系，由于初等变换是三种基本变换的组合，所以只需分别对三种基本变换进行讨论即可：</p>
<ol>
<li><p>某两行互换：只影响行列式的符号，因为约定了所有多项式都是首1多项式，所以这种变换对子式集合无影响，即 $\mathscr{A}=\mathscr{B}$ ，那么必有 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>某行乘以一个非零常数：同样，因为约定了所有多项式都是首1多项式，所以也不会有影响，即 $\mathscr{A}=\mathscr{B}$ ，那么必有 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>某行乘以一个多项式再加到另一行上。假设是第 $i$ 行乘以 $h(\lambda)$ 加到第 $j$ 行。那么：</p>
<ul>
<li><p>如果 $f(\lambda)$ 没有取到第 $j$ 行，那么该子式不发生变化，即 $f(\lambda)\in\mathscr{A}$ ；</p>
</li>
<li><p>如果 $f(\lambda)$ 取到了第 $j$ 行：</p>
<ul>
<li><p>如果同时取到了第 $i$ 行，那么该子式不发生变化，即 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>如果没有取到第 $i$ 行，显然  $f(\lambda)\notin\mathscr{A}$  ，但是可以将它对应的行列式拆分：</p>
<script type="math/tex; mode=display">
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a}_j+\boldsymbol{a_i}\cdot h(\lambda) \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right| = 
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a}_j \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right|+
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a_i} \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right|\cdot h(\lambda)</script><p>即：$f(\lambda)=g(\lambda)+w(\lambda)\cdot h(\lambda)$，其中 $g(\lambda),w(\lambda)\in\mathscr{A}$ ，所以 $\mathscr{A}$ 的公因式必整除 $f(\lambda)$ </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>综上，$\mathscr{A}$ 的公因式必能整除 $\mathscr{B}$ 中的所有子式，由于初等变换可逆知，$\mathscr{B}$ 的公因式也必能整除 $\mathscr{A}$ 中的所有子式，从而二者的最高公因式相同</p>
</li>
<li><p><strong>不变因子 $d_{i}(\lambda)$</strong>  </p>
<p>记 $k$ 阶行列式因子为 $D_k(\lambda)$ ，初等变换不改变行列式因子，所以：</p>
<script type="math/tex; mode=display">
d_1(\lambda) = D_1(\lambda),\ d_i(\lambda)=D_i(\lambda)/D_{i-1}(\lambda)</script><p>因此，称 $d_i(\lambda)$ 为不变因子（行列式因子唯一，所以 $d_i(\lambda)$ 一定唯一）</p>
</li>
</ul>
</li>
</ul>
<h5 id="两种方法求Smith型"><a href="#两种方法求Smith型" class="headerlink" title="两种方法求Smith型"></a>两种方法求Smith型</h5><ul>
<li><p>初等变换：找次数最低项，要么能整除，要么能降次（带余除法）</p>
<p>例：</p>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}\lambda(\lambda+1)&0&0\\0&\lambda&0\\0&0&(\lambda+1)^2\end{bmatrix} 

&\xrightarrow[]{最低次放左上角}
&\begin{bmatrix}\lambda&0&0\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[加到第一行]{不能整除的某行}
&\begin{bmatrix}\lambda&0&(\lambda+1)^2\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[]{带余除法降次}
&\begin{bmatrix}\lambda&0&1\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[重复带余除法直到能整除]{最低次换到左上角}
&\begin{bmatrix}1&0&\lambda\\0&\lambda(\lambda+1)&0\\(\lambda+1)^2&0&0\end{bmatrix} \notag \\

&\xrightarrow[]{同行同列化零}
&\begin{bmatrix}1&0&0\\ 0&\lambda(\lambda+1)&0\\ 0&0&-\lambda(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[]{化为首1多项式}
&\begin{bmatrix}1&0&0\\ 0&\lambda(\lambda+1)&0\\ 0&0&\lambda(\lambda+1)^2\end{bmatrix} \notag \\
\end{align}</script></li>
<li><p>计算所有行列式因子</p>
<p>同上例，有 $D_1(\lambda)=1,D_2(\lambda)=\lambda(\lambda+1),D_3=\lambda^2(\lambda+1)^3$ ，故而 $d_1(\lambda)=1, d_2(\lambda)=\lambda(\lambda+1),d_3(\lambda)=\lambda(\lambda+1)^2$ </p>
</li>
</ul>
<h5 id="单位模阵可写成初等矩阵乘积"><a href="#单位模阵可写成初等矩阵乘积" class="headerlink" title="单位模阵可写成初等矩阵乘积"></a>单位模阵可写成初等矩阵乘积</h5><ul>
<li><p>单位模阵的 Smith 型为单位矩阵</p>
<p>下面给出证明：</p>
<p>$\boldsymbol{U}(\lambda)$ 是单位模阵 $\Leftrightarrow |\boldsymbol{U}(\lambda)|=c\neq0$ （为非零常数）$\Leftrightarrow\boldsymbol{U}(\lambda)$ 的 $n$ 阶行列式因子为1，且 $r=\text{rank}(\boldsymbol{U})=n$ </p>
<p>又：$D_n(\lambda)=D_1(\lambda)\frac{D_2(\lambda)}{D_1(\lambda)}\cdots\frac{D_n(\lambda)}{D_{n-1}(\lambda)}=d_1(\lambda)d_2(\lambda)\cdots d_n(\lambda)$  </p>
<p>所以：$d_i(\lambda)=1$ ，证毕</p>
</li>
</ul>
<p>据此，单位模阵经过若干次初等变换后可以变成单位矩阵，写成矩阵的形式即为：</p>
<script type="math/tex; mode=display">
\boldsymbol{P}_s(\lambda)\cdots\boldsymbol{P}_1(\lambda)\boldsymbol{U}(\lambda)\boldsymbol{Q}_1(\lambda)\cdots\boldsymbol{Q}_t(\lambda)=\boldsymbol{I}</script><p>初等矩阵的逆矩阵仍为初等矩阵，因此：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}(\lambda)=\boldsymbol{P}_1^{-1}(\lambda)\cdots\boldsymbol{P}_s^{-1}(\lambda)\boldsymbol{Q}_t^{-1}(\lambda)\boldsymbol{Q}_1^{-1}(\lambda)</script><h4 id="数域矩阵相似最简型问题"><a href="#数域矩阵相似最简型问题" class="headerlink" title="数域矩阵相似最简型问题"></a>数域矩阵相似最简型问题</h4><ul>
<li>特征矩阵：给定 $\boldsymbol{A}\in\mathbb{F}^{n\times n}$ ，称多项式矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 为矩阵 $\boldsymbol{A}$ 的特征矩阵</li>
</ul>
<h5 id="数域矩阵相似-Leftrightarrow-特征矩阵等价"><a href="#数域矩阵相似-Leftrightarrow-特征矩阵等价" class="headerlink" title="数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价"></a>数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价</h5><p>把一个受约束的相似问题【 $\boldsymbol{AP}=\boldsymbol{PB}$ 行列变换必须配套】转换成了一个不受约束的等价问题【 $\boldsymbol{U}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B}$ 行列变换无需配套】 </p>
<p>下面给出证明：</p>
<ul>
<li><p>多项式矩阵的<strong>次数</strong></p>
<p>若 $\boldsymbol{A}(\lambda) = A_0+A_1\lambda+A_2\lambda^2+\cdots+A_r\lambda^r,\ 且\ A_r\neq0$ ，则称 $\boldsymbol{A}(\lambda)$ 的次数为 $r$ ，记作 $\partial(\boldsymbol{A}(\lambda))=r$ 。特别地，零多项式矩阵的次数无意义。</p>
</li>
<li><p>多项式矩阵<strong>乘积的次数</strong> </p>
<p> $\boldsymbol{A}(\lambda)\boldsymbol{B}(\lambda)=\boldsymbol{C}(\lambda)$，且 $\boldsymbol{A}(\lambda) = A_0+A_1\lambda+\cdots+A_r\lambda^r$ ，若满足：</p>
<p>​    1）三个矩阵均非零（零矩阵的次数无意义） </p>
<p>​    2）$A_r\in \mathbb{F}^{m\times m}$ 可逆（保证 $\boldsymbol{C}(\lambda)$ 的最高次矩阵系数 $C_{r+s}(\lambda)=A_r(\lambda)B_s(\lambda)$ 非零）</p>
<p>那么 $\partial(\boldsymbol{C}(\lambda))=\partial(\boldsymbol{A}(\lambda))+\partial(\boldsymbol{B}(\lambda))$ </p>
</li>
<li><p>多项式矩阵的带余除法（以左除为例）：</p>
<p>$\boldsymbol{A}(\lambda) = A_0+A_1\lambda+\cdots+A_r\lambda^r\in(\mathbb{F}[\lambda])^{m\times m}$ ，若满足 $A_r\in\mathbb{F}^{m\times m}$ <strong>可逆</strong>，那么对非零矩阵 $\boldsymbol{B}(\lambda)\in(\mathbb{F}[\lambda])^{m\times n}$ ，存在<strong>唯一</strong>矩阵 $\boldsymbol{Q}(\lambda), \boldsymbol{R}(\lambda)$ ，使得：$\boldsymbol{B}(\lambda)=\boldsymbol{A}(\lambda)\boldsymbol{Q}(\lambda)+\boldsymbol{R}(\lambda)$ ，其中 $\boldsymbol{R}(\lambda)=\boldsymbol{0}$ 或 $\partial(\boldsymbol{R}(\lambda))&lt;\partial(\boldsymbol{A}(\lambda))$  </p>
</li>
</ul>
<p>$\Rightarrow$ ：取 $\boldsymbol{U}(\lambda)=\boldsymbol{P}^{-1},\boldsymbol{V}(\lambda)=\boldsymbol{P}$ ，因为 $\boldsymbol{P}$ 可逆，故行列式为非零常数，满足单位模阵的要求</p>
<p>$\Leftarrow$ ：从 $\boldsymbol{U},\boldsymbol{V}$ 找 $\boldsymbol{P}$ </p>
<p>根据多项式矩阵带余除法，因为 $\boldsymbol{I}$ 可逆，所以：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}(\lambda)=(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)+\boldsymbol{R}(\lambda)</script><p>其中：$\boldsymbol{R}(\lambda)=\boldsymbol{0}$ ，或 $\partial(\boldsymbol{R}(\lambda))&lt;\partial(\lambda\boldsymbol{I}-\boldsymbol{B})=1$ ，即 $\boldsymbol{R}(\lambda)=\boldsymbol{R}\in\mathbb{F}^{n\times n}$ 为常数矩阵。因此：</p>
<script type="math/tex; mode=display">
\begin{align}
&\boldsymbol{U}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B} \notag\\

\Leftrightarrow &[(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)+\boldsymbol{R}](\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B} \notag\\

\Leftrightarrow &\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})=(\lambda\boldsymbol{I}-\boldsymbol{B})[\boldsymbol{V}^{-1}(\lambda)-\boldsymbol{Q}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})] \notag

\end{align}</script><p>比较等式两端变量 $\lambda$ 的系数可知，$\boldsymbol{V}^{-1}(\lambda)-\boldsymbol{Q}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})$ 也是常数矩阵，记作 $\boldsymbol{S}$ ，故而：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})=(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{S}</script><p>且由 $\lambda$ 系数知：$\boldsymbol{R}=\boldsymbol{S}$ ，从而有 $\boldsymbol{RA}=\boldsymbol{BR}$ ，只需证 $\boldsymbol{R}$ 可逆即可</p>
<p>要证明可逆，我们期望找出一个矩阵 $\boldsymbol{P}$ ，使得 $\boldsymbol{RP}=\boldsymbol{I}$ .</p>
<p>考虑到 $\boldsymbol{R}$ 是由矩阵 $\boldsymbol{U}(\lambda)$ 对矩阵 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 作带余除法所得，对应地，也可以有：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}^{-1}(\lambda)=(\lambda\boldsymbol{I}-\boldsymbol{A})\widetilde{\boldsymbol{Q}}(\lambda)+\widetilde{\boldsymbol{R}}</script><p>将方程 (7) (10) 代入 $\boldsymbol{U}(\lambda)\boldsymbol{U}^{-1}(\lambda)=\boldsymbol{I}$ ，整理得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})\widetilde{\boldsymbol{Q}}(\lambda)+\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}-(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)\boldsymbol{U}^{-1}(\lambda)</script><p>代入方程 (9) ，整理得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}-(\lambda\boldsymbol{I}-\boldsymbol{B})[\boldsymbol{Q}(\lambda)\boldsymbol{U}^{-1}(\lambda)+\boldsymbol{S}\widetilde{\boldsymbol{Q}}(\lambda)]</script><p>比较方程 (12) 两边 $\lambda$ 系数知：$\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}$ ，从而 $\boldsymbol{R}$ 可逆。</p>
<p>证毕。</p>
<h5 id="特征矩阵的-Smith-型"><a href="#特征矩阵的-Smith-型" class="headerlink" title="特征矩阵的 Smith 型"></a>特征矩阵的 Smith 型</h5><p>因为 $|\lambda\boldsymbol{I}-\boldsymbol{A}|$ 的最高次项 $\lambda^n$ 的系数必为1，因此，$\lambda\boldsymbol{I}-\boldsymbol{A}$ 作为多项式矩阵的秩为 $n$ 。从而它的Smith型矩阵为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
d_1(\lambda)&\\
&\ddots&\\
&&d_n(\lambda)
\end{bmatrix}</script><p>因此：$d_1(\lambda)\cdots d_n(\lambda)=|\lambda\boldsymbol{I}-\boldsymbol{A}|\Rightarrow\partial(d_1(\lambda))+\cdots+\partial(d_n(\lambda))=n$ 。若某个 $d_i(\lambda)$ 的次数为 $n_i\neq1$ ，那么必将多出 $n_i-1$ 个常数不变因子，根据首1多项式的约定，这些不变因子最终都会化为1。因此上述Smith型矩阵进一步表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&&&&&\\
&\ddots&&&&\\
&&1&&&\\
&&&h_1(\lambda)&&\\
&&&&\ddots&\\
&&&&&h_p(\lambda)
\end{bmatrix}</script><p>其中，$\partial(h_i(\lambda))=n_i$ 。假设有 $p$ 个非常数不变因子，那么等于1的不变因子共有 $n-p$ 个，且满足 $n-p=(n_1-1)+\cdots+(n_p-1)$ ，因此将对角线上的元素按一个 $h_i(\lambda)$ ，$n_i-1$ 个1配对进行重组，Smith型矩阵等价于如下矩阵：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{cccc|c|cccc}
    1 & & & & & & & & \\
    & \ddots & & & & & & & \\
    & & 1 & & & & & & \\
    & & & h_1(\lambda) & & & & & \\
    \hline
    & & & & \ddots & & & & \\
    \hline
    & & & & & 1 & & & \\
    & & & & & & \ddots & & \\
    & & & & & & & 1 & \\
    & & & & & & & & h_p(\lambda)
\end{array}
\right]</script><p>每一小块都是 $\begin{bmatrix} 1&amp;&amp;&amp;\\&amp;\ddots&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;h_i(\lambda)\end{bmatrix}_{n_i\times n_i}$ </p>
<ul>
<li><p>特征矩阵的初等因子组</p>
<p>初等因子指的是将特征矩阵的所有非常数不变因子在 $\mathbb{F}[\lambda]$ 中作质因式分解时出现的质因式的方幂。所有初等因子组成初等因子组（显然初等因子组中的某个初等因子可能重复出现）。</p>
<p>$h_i(\lambda)\xlongequal{质因式分解}w_1^{r_{i1}}(\lambda)\cdots w_j^{r_{ij}}(\lambda)$ ，则每个质因式的方幂 $w_j^{r_{ij}}(\lambda)$ 就是一个初等因子，所有方幂组成了特征矩阵的初等因子组。</p>
<p>（实数域中的质因式包括 $x-c$ 和 $x^2+bx+c,且\ b^2-4c&lt;0$ 两种情况；复数域中的质因式只有 $x-c$ 一种情况）</p>
</li>
<li><p>初等因子组与不变因子（行列式因子、初等因子）互相唯一决定</p>
<p>由不变因子决定初等因子组：根据定义，显然</p>
<p>​    <strong>例</strong>：已知矩阵 $\boldsymbol{A}$ 的特征矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 的 Smith型 为：$\begin{bmatrix}1&amp;0&amp;0\\0&amp;(\lambda+1)^2&amp;0\\0&amp;0&amp;\lambda(\lambda+1)^2\end{bmatrix}$ </p>
<p>​    显然初等因子组为：$\{(\lambda+1)^2,\lambda, (\lambda+1)^2\}$</p>
<p>由初等因子组决定不变因子：</p>
<p>​    <strong>例</strong>：设 $\boldsymbol{A}\in\mathbb{C}^{8\times8}$ ，且初等因子组为：$\{\lambda,\lambda^2,\lambda,(\lambda+1)^2,(\lambda+1)^2\}$ ，求不变因子。</p>
<p>​    由于不变因子满足 $d_i(\lambda)|d_{i+1}(\lambda)$ 所以最后一个不变因子的次数应该最高且所有质因式都应出现，以此类推：</p>
<script type="math/tex; mode=display">
\begin{align}
&d_8(\lambda)=\lambda^2(\lambda+1)^2 \notag \\
&d_7(\lambda)=\lambda(\lambda+1)^2 \notag \\
&d_6(\lambda)=\lambda \notag \\
&d_5(\lambda)=\cdots=d_1(\lambda)=1 \notag
\end{align}</script></li>
</ul>
<p>下面通过对非常数不变因子 $h_i(\lambda)$ 在复数域上作质因式分解，将上述（15）进一步化为一种更特殊的形式</p>
<script type="math/tex; mode=display">
h_i(\lambda)=(\lambda-c_1)^{r_1}(\lambda-c_2)^{r_2}\cdots(\lambda-c_k)^{r_k}</script><p>显然有 $r_1+r_2+\cdots+r_k=n_i$ ，逆用初等因子分解，因为子矩阵  $\begin{bmatrix} 1&amp;&amp;&amp;\\&amp;\ddots&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;h_i(\lambda)\end{bmatrix}_{n_i\times n_i}$ 有上述 $k$ 个初等因子，所以可以等价于（有相同的初等因子组）：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{cccc|c|cccc}
    1 & & & & & & & & \\
    & \ddots & & & & & & & \\
    & & 1 & & & & & & \\
    & & & (\lambda-c_1)^{r_1} & & & & & \\
    \hline
    & & & & \ddots & & & & \\
    \hline
    & & & & & 1 & & & \\
    & & & & & & \ddots & & \\
    & & & & & & & 1 & \\
    & & & & & & & & (\lambda-c_k)^{r_k}
\end{array}
\right]</script><h5 id="矩阵相似在多项式特征邻域中的各种刻画"><a href="#矩阵相似在多项式特征邻域中的各种刻画" class="headerlink" title="矩阵相似在多项式特征邻域中的各种刻画"></a>矩阵相似在多项式特征邻域中的各种刻画</h5><p>若 $\boldsymbol{A},\boldsymbol{B}\in\mathbb{F}^{n\times n}$ ，则下列结论等价：</p>
<ol>
<li>$\boldsymbol{A}$ 与 $\boldsymbol{B}$ 相似；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 作为多项式矩阵等价；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 Smith型；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 不变因子；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 行列式因子；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 初等因子组；</li>
</ol>
<p>例：证明 $\boldsymbol{A}$ 与 $\boldsymbol{A}^T$ 相似</p>
<p>因为只提供了抽象矩阵，所以适用于具体形式的2/3/4/6方法都不容易处理，因此考虑行列式因子</p>
<p>因为 $(\lambda\boldsymbol{I}-\boldsymbol{A})^T=\lambda\boldsymbol{I}-\boldsymbol{A}^T$ ，而矩阵转置行列式不变，因此显然 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{A}^T$ 有相同的行列式因子</p>
<h5 id="多项式矩阵等价的证明方法"><a href="#多项式矩阵等价的证明方法" class="headerlink" title="多项式矩阵等价的证明方法"></a>多项式矩阵等价的证明方法</h5><ol>
<li>定义法：初等变换能否转化</li>
<li>相同的行列式因子 / Smith型 / 不变因子 / 初等因子组</li>
</ol>
<h4 id="Jordan标准型"><a href="#Jordan标准型" class="headerlink" title="Jordan标准型"></a>Jordan标准型</h4><p>以下均在复数域上考虑，因而质因式只有 $\lambda-c$ 一种类型。</p>
<p>综合上面所说，特征矩阵可以有如下等价：</p>
<script type="math/tex; mode=display">
\lambda\boldsymbol{I}-\boldsymbol{A}\sim \boldsymbol{J}(\lambda)=
\begin{bmatrix}
\boldsymbol{J}_1(\lambda) &&\\
&\ddots&\\
&&\boldsymbol{J}_q(\lambda)
\end{bmatrix},
\boldsymbol{J}_i(\lambda)=
\begin{bmatrix}
1 &&& \\
& \ddots && \\
&& 1 & \\
&&& (\lambda-c_i)^{r_i}
\end{bmatrix}_{r_i\times r_i}</script><p>其中：$(\lambda-c_i)^{r_i},i=1,…,q$ 是特征矩阵的初等因子组。</p>
<p>从而：$\boldsymbol{A}\longrightarrow\lambda\boldsymbol{I}-\boldsymbol{A}\sim\boldsymbol{J}(\lambda)\sim\lambda\boldsymbol{I}-\boldsymbol{J}\longleftarrow\boldsymbol{J}$ ，满足这个条件的矩阵都与 $\boldsymbol{A}$ 相似</p>
<p>我们要做的，就是求出其中最简单的矩阵，也就是相似最简型</p>
<p>进一步，这个问题又可以拆分成针对各个子块的类似的问题，即：求一个尽可能简单的矩阵 $\boldsymbol{J}_i\in\mathbb{C}^{r_i\times r_i}$ ，使得 $\lambda\boldsymbol{I}_{r_i}-\boldsymbol{J}_i\sim\boldsymbol{J}_i(\lambda)$ </p>
<h5 id="Jordan块的Simth型"><a href="#Jordan块的Simth型" class="headerlink" title="Jordan块的Simth型"></a>Jordan块的Simth型</h5><p>若当块：对角线元素全为 $c_1$ ，次对角线元素均为1的矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_i=\begin{bmatrix}
c_1 & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & 1 \\
0 & \cdots & \cdots& c_1
\end{bmatrix}_{r_i\times r_i}</script><p>结论：若当块所对应特征矩阵的Simth型即满足 $\lambda\boldsymbol{I}_{r_i}-\boldsymbol{J}_i\sim\boldsymbol{J}_i(\lambda)$ </p>
<p>下面给出证明（本质就是证明两个多项式矩阵等价） ：</p>
<ul>
<li>方法一：定义法</li>
</ul>
<script type="math/tex; mode=display">
左边=\begin{bmatrix}
\lambda-c_1 & -1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & -1 \\
0 & \cdots & \cdots& \lambda-c_1
\end{bmatrix}_{r_i\times r_i}</script><ul>
<li>方法二：计算两边的行列式因子</li>
</ul>
<p>由于左边的 $r_i-1$ 阶行列式中有一个是1（右上角子块），所以左边矩阵的 $r_i-1$ 阶最高公因式只能是1，即左边矩阵的 $r_i-1$ 阶行列式因子为1。</p>
<p>从而所有比它低阶的行列式因子也只能是1，因为 $D_{i-1}(\lambda)$ 必须整除 $D_{i}(\lambda)$ 。</p>
<p>而左侧行列式等于右侧行列式，即左侧 $r_i$ 阶行列式因子与右侧相同。</p>
<p>故而两边矩阵的任意阶行列式因子都相同，从而矩阵等价。</p>
<p>综上所述，有如下定理：</p>
<p>给定矩阵 $\boldsymbol{A}\in\mathbb{C}^{n\times n}$ ，其特征矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 的初等因子组为：$(\lambda-c_1)^{r_1},\cdots,(\lambda-c_q)^{r_q}$ ，取</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_i=\begin{bmatrix}
c_i & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & 1 \\
0 & \cdots & \cdots& c_i
\end{bmatrix}_{r_i\times r_i}</script><p>则 $\boldsymbol{A}$ 的相似最简型为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\sim\boldsymbol{J}=
\begin{bmatrix}
J_1 &  \cdots & 0 \\
\vdots & \ddots & \vdots \\
0 & \cdots & J_q
\end{bmatrix}</script><p>而 $\boldsymbol{J}$ 就是矩阵 $\boldsymbol{A}$ 的 Jordan标准型</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">矩阵分析学习笔记1：线性空间与线性映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-27 13:30:03" itemprop="dateCreated datePublished" datetime="2021-05-27T13:30:03+08:00">2021-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-29 08:45:42" itemprop="dateModified" datetime="2021-05-29T08:45:42+08:00">2021-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">矩阵分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter1-线性空间与线性映射"><a href="#Chapter1-线性空间与线性映射" class="headerlink" title="Chapter1 线性空间与线性映射"></a>Chapter1 线性空间与线性映射</h2><h4 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h4><h5 id="域-mathbb-F"><a href="#域-mathbb-F" class="headerlink" title="域 $\mathbb{F}$"></a>域 $\mathbb{F}$</h5><p>一个域是一个运算系统，包括一个集合和在集合上定义的两种运算（加法和乘法）且两种运算都满足一定的运算规则</p>
<p>常用域：有理数域 $\mathbb{Q}$ ，实数域 $\mathbb{R}$ ，复数域 $\mathbb{C}$ </p>
<h5 id="二元加法运算"><a href="#二元加法运算" class="headerlink" title="二元加法运算+"></a>二元加法运算+</h5><p>给定非空集合 $\mathbb{V}$ 和域 $\mathbb{F}$ ，若存在映射 $\sigma:\mathbb{V}\times \mathbb{V}\rightarrow \mathbb{V},(\boldsymbol{\alpha},\boldsymbol{\beta})\mapsto\sigma(\boldsymbol{\alpha},\boldsymbol{\beta})$ ，即对集合 $\mathbb{V}$ 中的任意元素 $\boldsymbol{\alpha},\boldsymbol{\beta}$ ，在集合 $\mathbb{V}$ 中都存在唯一元素 $\boldsymbol{\gamma}$ ，使得 $\boldsymbol{\gamma}=\boldsymbol{\alpha}+\boldsymbol{\beta}\in\mathbb{V}$，则称 $\sigma$ 为集合 $\mathbb{V}$ 上的加法 。</p>
<p>注：定义中的 $\times$ 是集合之间的乘法，称为卡氏积/笛卡尔积，指的是从两个集合中任取一个元素组成的所有有序元素对的集合：$\mathbb{S_1}\times\mathbb{S_2}=\{(a,b)|a\in\mathbb{S_1},b\in\mathbb{S_2}\}$ </p>
<h5 id="二元数乘运算-cdot"><a href="#二元数乘运算-cdot" class="headerlink" title="二元数乘运算 $\cdot$"></a>二元数乘运算 $\cdot$</h5><p>给定非空集合 $\mathbb{V}$ 和数域 $\mathbb{F}$ ，若存在映射 $\sigma:\mathbb{V}\times \mathbb{F}\rightarrow \mathbb{V},(\boldsymbol{\alpha},k)\mapsto\sigma(\boldsymbol{\alpha},k)$ ，即对集合 $\mathbb{V}$ 中的任意元素 $\boldsymbol{\alpha}$ 和数域 $\mathbb{F}$ 中的任意元素 $k$ ，在集合 $\mathbb{V}$ 中都存在唯一元素 $\boldsymbol{\gamma}$ ，使得 $\boldsymbol{\gamma}=\boldsymbol{\alpha}\cdot k\in\mathbb{V}$，则称 $\sigma$ 为集合 $\mathbb{V}$ 上的数乘 。</p>
<h5 id="通常的运算规则"><a href="#通常的运算规则" class="headerlink" title="通常的运算规则"></a>通常的运算规则</h5><ol>
<li>加法的运算规则<ul>
<li>交换律：$\boldsymbol{\alpha}+\boldsymbol{\beta}=\boldsymbol{\beta}+\boldsymbol{\alpha}$ </li>
<li>结合律：$(\boldsymbol{\alpha}+\boldsymbol{\beta})+\boldsymbol{\gamma}=\boldsymbol{\alpha}+(\boldsymbol{\beta}+\boldsymbol{\gamma})$ </li>
<li>有零元：$\exists \boldsymbol{e}\in\mathbb{V},s.t.\ \boldsymbol{e}+\boldsymbol{\alpha}=\boldsymbol{\alpha}\ 对\ \forall \boldsymbol{\alpha}\in\mathbb{V}\ 成立$ </li>
<li>有逆元：$对\ \forall\boldsymbol{\alpha}\in\mathbb{V},\exists\boldsymbol{\beta}\in\mathbb{V},s.t.\ \boldsymbol{\alpha}+\boldsymbol{\beta}=\boldsymbol{e},记\ \boldsymbol{\beta}=-\boldsymbol{\alpha}$ </li>
</ul>
</li>
<li>数乘的运算规则<ul>
<li>交换律：$\boldsymbol{\alpha}\cdot k=k\cdot\boldsymbol{\alpha}$ （一般将对列向量数乘的数写在右侧，对行向量数乘的数写在左侧，这样可以和矩阵乘法作类比）</li>
<li>结合律：$(\boldsymbol{\alpha}\cdot k)\cdot l=\boldsymbol{\alpha}\cdot (kl)$ （注：左边做了两次数乘，右边做了一次 $\mathbb{F}$ 中数的乘法和一次数乘）</li>
<li>分配律：$(\boldsymbol{\alpha}+\boldsymbol{\beta})\cdot k=\boldsymbol{\alpha}\cdot k+\boldsymbol{\beta}\cdot k,\quad \boldsymbol{\alpha}\cdot(k_1+k_2)=\boldsymbol{\alpha}\cdot k_1 + \boldsymbol{\alpha}\cdot k_2$ （注：第二个式子左边做的是 $\mathbb{F}$ 中数的加法，右边做的是向量加法）</li>
<li>与 $\mathbb{F}$ 中 1 的关系：$\boldsymbol{\alpha}\cdot 1=\boldsymbol{\alpha}$ </li>
</ul>
</li>
</ol>
<h5 id="线性空间-1"><a href="#线性空间-1" class="headerlink" title="线性空间"></a>线性空间</h5><p>若集合 $\mathbb{V}$ 满足上述两种运算，且这两种运算满足通常的运算规则，则称集合 $\mathbb{V}$ 关于此加法和数乘是域 $\mathbb{F}$ 上的线性空间。（一般也把这种线性空间称为向量空间，$\mathbb{V}$ 中的元素称为向量）</p>
<p>注1：空间这个概念只是为了类比2维或3维几何空间的一个概念，更好的理解为元素的集合，线性空间中的元素统称为<strong>抽象向量</strong> </p>
<p>注2：集合 $\mathbb{V}$ 中的元素分别为数组、函数、有向线段时，对应的线性空间称为数域空间、函数空间、几何空间</p>
<p>注3：数域 $\mathbb{F}$ 上的<strong>标准线性空间</strong> $\mathbb{F}^n$ （数域空间）</p>
<p>​    $\mathbb{V}:=\mathbb{F}^n=\begin{matrix}n\\ \overbrace{\mathbb{F}\times\mathbb{F}\times \cdots\times \mathbb{F} }\end{matrix}$ ，其元素称为 n元组（n-tuple） </p>
<p>​    加法：$\begin{bmatrix}v_1\\ \vdots\\ v_n\end{bmatrix} + \begin{bmatrix}w_1\\ \vdots\\ w_n\end{bmatrix} = \begin{bmatrix}v_1+w_1\\ \vdots\\ v_n+w_n\end{bmatrix}$</p>
<p>​    数乘：$\begin{bmatrix}v_1\\ \vdots\\ v_n\end{bmatrix}\cdot k=\begin{bmatrix}v_1\cdot k\\ \vdots\\ v_n\cdot k\end{bmatrix}$ </p>
<p>​    容易证明，定义的加法和数乘满足上述运算规则</p>
<p>注4：对于<strong>几何空间（有向线段的集合）</strong>，加法运算采用平行四边形或三角形法则进行计算，数乘运算表示对有向线段进行同向或反向伸缩</p>
<h4 id="向量组的线性相关性"><a href="#向量组的线性相关性" class="headerlink" title="向量组的线性相关性"></a>向量组的线性相关性</h4><p>向量组：$\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$</p>
<p>抽象矩阵：$[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]$ </p>
<p>定义方程组：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\boldsymbol{x}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_p \end{bmatrix}=\boldsymbol{0}</script><p>若无非零解，则向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性无关；若存在非零解，则向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性相关</p>
<h5 id="向量组的线性表出"><a href="#向量组的线性表出" class="headerlink" title="向量组的线性表出"></a>向量组的线性表出</h5><p>定义方程组：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\boldsymbol{x}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_p \end{bmatrix}=\boldsymbol{\beta}</script><p>若有解，则向量 $\boldsymbol{\beta}$ 可由向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性表出</p>
<p>定义方程组：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\boldsymbol{X}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]
\begin{bmatrix}
    x_{11} &x_{12}\ \ \cdots&x_{1p} \\
    x_{21} &x_{22}\ \ \cdots&x_{2p} \\
    \vdots &\ddots          &\vdots \\ 
    x_{p1} &x_{p2}\ \ \cdots&x_{pp}
\end{bmatrix}
=[\boldsymbol{\beta}_1\ \boldsymbol{\beta}_2\ \cdots\ \boldsymbol{\beta}_p]
=\boldsymbol{B}</script><p>若有解，则向量组 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_p$ 可由向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性表出</p>
<p>向量组的线性表示具有传递性</p>
<h5 id="有限维线性空间的基（坐标系）与坐标"><a href="#有限维线性空间的基（坐标系）与坐标" class="headerlink" title="有限维线性空间的基（坐标系）与坐标"></a>有限维线性空间的基（坐标系）与坐标</h5><p>设集合 $\mathbb{V}$ 是 数域 $\mathbb{F}$ 上的线性空间，有正整数 $n$ 及 $\mathbb{V}$ 中的向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 满足以下两个条件：</p>
<ul>
<li><p>线性无关性：向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 线性无关</p>
</li>
<li><p>生成性：$\forall \boldsymbol{\alpha} \in \mathbb{V} $ ，均可由 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 线性表出</p>
<script type="math/tex; mode=display">
\boldsymbol{\alpha}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n]\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_n \end{bmatrix}=\boldsymbol{A}\boldsymbol{x}</script></li>
</ul>
<p>则称向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 为 $n$ 维线性空间 $\mathbb{V}$ 的一组基，矩阵 $A=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n]$ 称为基矩阵，向量 $\boldsymbol{x}=[x_1\ x_2\ \cdots\ x_n]^T\in\mathbb{F}^n$ 称为抽象向量 $\boldsymbol{\alpha}$ 在基 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 下的坐标。</p>
<p>换言之，抽象向量 = 基矩阵 $\cdot$ 坐标向量</p>
<p>注1：基向量组的线性无关性保证线性空间中的抽象向量在该基下的坐标是唯一的，生成性保证空间中的任意向量在该基下都有坐标；</p>
<p>注2：基（坐标系）实现了抽象线性空间到标准线性空间的一一对应（通过基实现对抽象向量的具体化）</p>
<h5 id="标准线性空间-mathbb-F-n-的标准基与一般基"><a href="#标准线性空间-mathbb-F-n-的标准基与一般基" class="headerlink" title="标准线性空间 $\mathbb{F}^n$ 的标准基与一般基"></a>标准线性空间 $\mathbb{F}^n$ 的标准基与一般基</h5><p>标准基：</p>
<script type="math/tex; mode=display">
\boldsymbol{e}_1=\begin{bmatrix}1\\0\\\vdots\\0 \end{bmatrix},
\boldsymbol{e}_2=\begin{bmatrix}0\\1\\\vdots\\0 \end{bmatrix}
\boldsymbol{e}_n=\begin{bmatrix}0\\0\\\vdots\\1 \end{bmatrix},
\text{and}\ \boldsymbol{e}_i\in\mathbb{F}^n</script><p>标准基构成的基矩阵是单位矩阵 $\boldsymbol{I}_n=[\boldsymbol{e}_1\ \cdots\ \boldsymbol{e}_n]\in\mathbb{F}^{n\times n}$ </p>
<p>一般基：向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 是一般基 $\Leftrightarrow$ 线性无关 $\Leftrightarrow r(\boldsymbol{A})=n$ ，由一般基构成的基矩阵是<strong>非奇异矩阵</strong> </p>
<h4 id="线性子空间"><a href="#线性子空间" class="headerlink" title="线性子空间"></a>线性子空间</h4><p>设 $\mathbb{V}$ 是 $\mathbb{F}$ 上的线性空间，$\mathbb{W}\subseteq \mathbb{V}$ 是非空子集，若 $\mathbb{W}$ 中的元素也满足加法封闭性和数乘封闭性，则称 $\mathbb{W}$ 是 $\mathbb{V}$ 的一个线性子空间。</p>
<h5 id="向量组的生成子空间和子空间的生成组"><a href="#向量组的生成子空间和子空间的生成组" class="headerlink" title="向量组的生成子空间和子空间的生成组"></a>向量组的生成子空间和子空间的生成组</h5><p>设 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 是线性空间 $\mathbb{V}$ 中的一个向量组，定义集合 $\mathbb{W}$ 如下：  </p>
<script type="math/tex; mode=display">
\mathbb{W}=\text{span}
\{
\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p
\}
=\{
\boldsymbol{\alpha}_1\cdot x_1+\boldsymbol{\alpha}_2\cdot x_2+\cdots+\boldsymbol{\alpha}_p\cdot x_p|\forall x_i\in\mathbb{F}
\}</script><p>称 $\mathbb{W}$ 为向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 的生成子空间，显然 $\mathbb{W}$ 是 $\mathbb{V}$ 的子空间。</p>
<h5 id="矩阵的核与像"><a href="#矩阵的核与像" class="headerlink" title="矩阵的核与像"></a>矩阵的核与像</h5><p>设矩阵 $\boldsymbol{A}\in \mathbb{F}^{m\times n}$ ，定义矩阵 $\boldsymbol{A}$ 的核（kernel）与像（Image）如下：</p>
<script type="math/tex; mode=display">
\text{ker}\boldsymbol{A}=\{\boldsymbol{x}|\boldsymbol{A}\boldsymbol{x}=\boldsymbol{0},\boldsymbol{x}\in \mathbb{F}^n\} \subseteq \mathbb{F}^n \\
\text{Im}\boldsymbol{A}=\{\boldsymbol{A}\boldsymbol{x}|\forall \boldsymbol{x}\in \mathbb{F}^n\} \subseteq \mathbb{F}^m</script><p>显然，矩阵 $\boldsymbol{A}$ 的核即为齐次线性方程组的<strong>解空间</strong> ，像即为由列向量组张成的<strong>子空间</strong> </p>
<h5 id="子空间的交与和"><a href="#子空间的交与和" class="headerlink" title="子空间的交与和"></a>子空间的交与和</h5><p>设 $\mathbb{U}$ 和 $\mathbb{W}$ 是 $\mathbb{V}$ 的子空间，则</p>
<ul>
<li>$\mathbb{U}\cap\mathbb{W}$ 也是子空间，称为 $\mathbb{U}$ 和 $\mathbb{W}$ 的交（子空间）</li>
<li>$\mathbb{U}+\mathbb{W}=\text{span}\{\mathbb{U},\mathbb{W}\}=\{u+w|\forall u\in\mathbb{U},w\in\mathbb{W}\}$ 也是子空间，称为 $\mathbb{U}$ 和 $\mathbb{W}$ 的和（子空间）</li>
<li><strong>但</strong> $\mathbb{U}\cup\mathbb{W}$ 不一定是子空间！</li>
</ul>
<h4 id="线性映射"><a href="#线性映射" class="headerlink" title="线性映射"></a>线性映射</h4><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>若 $f:A\rightarrow B$ 是一个映射，则须满足以下两个充要条件：</p>
<ul>
<li>存在性：$\forall a\in A,\exists b\in B$ 与之对应</li>
<li>唯一性：$\forall a\in A$，在 $B$ 中的像 $b$ 是唯一的</li>
</ul>
<h5 id="线性映射，线性变换与线性同构"><a href="#线性映射，线性变换与线性同构" class="headerlink" title="线性映射，线性变换与线性同构"></a>线性映射，线性变换与线性同构</h5><p>设 $\mathbb{V_1},\mathbb{V_2}$ 是域 $\mathbb{F}$ 上的线性空间，$\sigma:\mathbb{V_1}\rightarrow\mathbb{V_2}$ 是映射，若满足以下两个条件：</p>
<ul>
<li>保加性：$\forall v_1,v_2\in\mathbb{V_1},\sigma(v_1+v_2)=\sigma(v_1)+\sigma(v_2)\in\mathbb{V_2}$ </li>
<li>保乘性：$\forall v\in\mathbb{V_1},\sigma(v\cdot k)=\sigma(v)\cdot k\in\mathbb{V_2}$  </li>
</ul>
<p>则称 $\sigma$ 是 $\mathbb{V_1}$ 到 $\mathbb{V_2}$ 的线性映射</p>
<p>若 $\mathbb{V_1}=\mathbb{V_2}=\mathbb{V}$ ，则称 $\sigma$ 为 $\mathbb{V}$ 上的线性变换</p>
<p><strong>线性映射不同空间，线性变换同一空间</strong></p>
<p>若 $\sigma$ 是可逆映射，则称其为线性同构（数学结构相同）。最典型的例子：抽象的线性空间选定基后，与标准线性空间线性同构</p>
<h5 id="矩阵-与-标准线性空间中的线性映射-是等同的"><a href="#矩阵-与-标准线性空间中的线性映射-是等同的" class="headerlink" title="矩阵 与 标准线性空间中的线性映射 是等同的"></a>矩阵 与 标准线性空间中的线性映射 是等同的</h5><ol>
<li><p>矩阵决定线性映射：给定 $\boldsymbol{A}\in\mathbb{F}^{m\times n}$ ，通过右乘列向量可以决定线性映射 $\sigma$ ：</p>
<script type="math/tex; mode=display">
\sigma:\mathbb{V_1}\rightarrow\mathbb{V_2};\ \boldsymbol{x}\mapsto\boldsymbol{y}=\boldsymbol{Ax}</script></li>
<li><p>线性映射决定矩阵：给定线性映射 $\sigma:\mathbb{V_1}\rightarrow\mathbb{V_2}$ ，一定能用某个矩阵 $\boldsymbol{A}$ 表示出来：</p>
<p>设 $\text{dim}(\mathbb{V_1})=n$ ，向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 是空间 $\mathbb{V_1}$ 的一组基；$\text{dim}(\mathbb{V_2})=m$ ，向量组 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 是空间 $\mathbb{V_2}$ 的一组基，则对 $\forall \boldsymbol{x}\in\mathbb{V_1}$ ，根据线性映射的保加性和保乘性，有：</p>
<script type="math/tex; mode=display">
\begin{align}
\sigma(\boldsymbol{x})&=\sigma([\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n]\boldsymbol{x}) \notag\\ &=\sigma(\boldsymbol{\alpha}_1x_1+\boldsymbol{\alpha}_2x_2+\cdots+\boldsymbol{\alpha}_nx_n) \notag\\
&=\sigma(\boldsymbol{\alpha}_1x_1)+\sigma(\boldsymbol{\alpha}_2x_2)+\cdots+\sigma(\boldsymbol{\alpha}_nx_n) \notag \\
&=\sigma(\boldsymbol{\alpha}_1)x_1+\sigma(\boldsymbol{\alpha}_2)x_2+\cdots+\sigma(\boldsymbol{\alpha}_n)x_n \\
&=[\sigma(\boldsymbol{\alpha}_1)\ \sigma(\boldsymbol{\alpha}_2)\ \cdots\ \sigma(\boldsymbol{\alpha}_n) ]\begin{bmatrix}x_1\\x_2\\ \vdots \\x_n \end{bmatrix} \notag \\
&=[\boldsymbol{\beta}_1\ \boldsymbol{\beta}_2\ \cdots\ \boldsymbol{\beta}_m]\boldsymbol{Ax} \notag
\end{align}</script><p>称矩阵 $\boldsymbol{A}$ 为线性映射 $\sigma$ 在入口基 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 与出口基 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 下的矩阵表示，写作：</p>
<script type="math/tex; mode=display">
\sigma[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n] =[\boldsymbol{\beta}_1\ \boldsymbol{\beta}_2\ \cdots\ \boldsymbol{\beta}_m]\boldsymbol{A}</script><p>线性映射 $\sigma$ 也可以用某个矩阵表示，即：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}线性\\映射\end{bmatrix}
\begin{bmatrix}入\\口\\基\end{bmatrix}=
\begin{bmatrix}出\\口\\基\end{bmatrix}
\begin{bmatrix}矩阵\\表示\end{bmatrix}</script><p>第 $i$ 列表示基向量 $\boldsymbol{\alpha}_i$ 在基 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 下的坐标；像 $\sigma(\boldsymbol{x})$ 在基 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 下的坐标为：</p>
<script type="math/tex; mode=display">
\boldsymbol{y}=\begin{bmatrix}y_1\\y_2\\ \vdots \\y_m \end{bmatrix}=\boldsymbol{A}\begin{bmatrix}x_1\\x_2\\ \vdots \\ \vdots \\x_n \end{bmatrix}=\boldsymbol{Ax}</script></li>
</ol>
<ul>
<li><p>从线性变换看旋转矩阵</p>
<p><img src="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/1622124672475.png" alt="从线性变换看旋转矩阵"></p>
</li>
</ul>
<h4 id="矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）"><a href="#矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）" class="headerlink" title="矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）"></a>矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）</h4><p>设矩阵 $\boldsymbol{A} ,\boldsymbol{B}\in\mathbb{F}^{m\times n}$ ，若存在可逆矩阵 $\boldsymbol{P}\in\mathbb{F}^{n\times n},\boldsymbol{Q}\in\mathbb{F}^{m\times m}$ ，使得 $\boldsymbol{AP}=\boldsymbol{QB}$ ，则称矩阵 $\boldsymbol{A},\boldsymbol{B}$ 等价；进一步，若 $m=n$ ，且 $\boldsymbol{AP}=\boldsymbol{PB}$ ，则称$\boldsymbol{A},\boldsymbol{B}$ 相似。</p>
<p><strong>从几何角度理解矩阵等价与几何相似</strong>（进一步理解公式11）</p>
<p>​    将 $\boldsymbol{A}$ 视为标准线性空间 $\mathbb{F}^n$ 到 $\mathbb{F}^m$ 的线性映射：$\ \boldsymbol{x}\mapsto\boldsymbol{y}=\boldsymbol{Ax}$ （具体矩阵抽象化）或视为某组未知入口基和出口基下的矩阵表示（不妨都取为标准基 $\boldsymbol{E_n},\boldsymbol{E_m}$ ）</p>
<p>​    由 $\boldsymbol{P},\boldsymbol{Q}$ 可逆 $\Rightarrow$ 其列向量可视为 $\mathbb{F}^n$ / $\mathbb{F}^m$ 空间中的两个一般基矩阵。称 $\boldsymbol{P}=[p_1\ p_2\ \cdots\ p_n]$ 为入口基，$\boldsymbol{Q}=[q_1\ q_2\ \cdots q_m]$ 为出口基。</p>
<p>​    由于 $\boldsymbol{AP}=\boldsymbol{QB}$ ，所以有下图成立，等式左右均表示从一般基P下的坐标到标准基下的坐标的线性映射。</p>
<p><img src="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/BFC87F8FC976B8B996157EB9E1405F6F.png" alt="img"></p>
<p>​    因此，<strong>矩阵等价</strong>的几何意义为：线性映射 $\boldsymbol{A}$ 在入口基 $\boldsymbol{P}$ 和出口基 $\boldsymbol{Q}$ 下的矩阵表示为 $\boldsymbol{B}$ ，换言之，相当于同一<strong>线性映射</strong>在不同基下的矩阵表示。</p>
<p>​    进一步，当 $m=n$ ，即在线性映射的两个空间是同一个空间的情况下，<strong>矩阵相似</strong>的几何意义为：同一<strong>线性变换</strong>在不同基下的矩阵表示。</p>
<h5 id="方阵-线性变换-的不变子空间"><a href="#方阵-线性变换-的不变子空间" class="headerlink" title="方阵(线性变换)的不变子空间"></a>方阵(线性变换)的不变子空间</h5><p>设方阵 $\boldsymbol{A}\in\mathbb{F}^{n\times n}$ ，子空间 $\mathbb{W}\subseteq\mathbb{F}^n$ ，若满足 $\boldsymbol{A}(\mathbb{W})=\{\boldsymbol{Ax}|\boldsymbol{x}\in\mathbb{W}\}\subseteq\mathbb{W}$ ，即线性变换 $\boldsymbol{A}$ 作用在子空间 $\mathbb{W}$ 上的元素的像依然在子空间 $\mathbb{W}$ 中，则称 $\mathbb{W}$ 是 $\boldsymbol{A}$ 的不变子空间。典型的不变子空间包括：$\{0\},\mathbb{F}^n,\text{ker}(\boldsymbol{A}),\text{im}(\boldsymbol{A})$ </p>
<p><strong>不变子空间等同于相似三角化</strong> </p>
<p>对相似方阵 $\boldsymbol{A},\boldsymbol{B}\in\mathbb{F}^{n\times n}$ ，有可逆矩阵 $\boldsymbol{P}$ 使得 $\boldsymbol{AP}=\boldsymbol{PB}$  ，将矩阵 $\boldsymbol{P}$ 写作分块矩阵 $\boldsymbol{P}=[\boldsymbol{P_{1,n\times n_1}}|\boldsymbol{P_{2,n\times (n-n_1)}} ]$ ，<strong>对应地</strong>，将矩阵 $\boldsymbol{B}$ 写作分块矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{B}=\left[
\begin{array}{c|c}
    \boldsymbol{B}_{11,n_1\times n_1} & \boldsymbol{B}_{12,n_1\times(n-n_1)} \\
    \hline
    \boldsymbol{B}_{21,(n-n_1)\times n_1} & \boldsymbol{B}_{22,(n-n_1)\times(n-n_1)}
\end{array}
\right]</script><p>则：</p>
<ul>
<li>$\boldsymbol{B}_{21}=\boldsymbol{0}\Leftrightarrow\text{im}\boldsymbol{P_1}$ 是 $\boldsymbol{A}$ 的不变子空间（上三角化）</li>
<li>$\boldsymbol{B}_{12}=\boldsymbol{0}\Leftrightarrow\text{im}\boldsymbol{P_2}$ 是 $\boldsymbol{A}$ 的不变子空间（下三角化）</li>
</ul>
<p>下面给出证明：</p>
<script type="math/tex; mode=display">
\boldsymbol{AP_1}=[\boldsymbol{P_1}|\boldsymbol{P_2}]
\begin{bmatrix}
    \boldsymbol{B_{11}}\\
    \boldsymbol{B_{21}}
\end{bmatrix}</script><p>即：</p>
<script type="math/tex; mode=display">
\boldsymbol{AP_1}=\boldsymbol{P_1B_{11}}+\boldsymbol{P_2B_{21}}</script><p>若 $\boldsymbol{B_{21}}=\boldsymbol{0}$ ，则 $\boldsymbol{AP_1}=\boldsymbol{P_1B_{11}}$ ，即 $\boldsymbol{A}\cdot\boldsymbol{p_{1j}}$ 均可由 $\boldsymbol{P_1}$ 的列向量的线性组合表出，而 $\boldsymbol{P_1}$ 的列向量的所有线性组合即为 $\text{im}\boldsymbol{P_1}\subseteq\mathbb{F}^{n_1}\subseteq\mathbb{F}^n$  ，从而 $\boldsymbol{A}$ 作用在子空间 $\text{im}\boldsymbol{P_1}$ 上的元素的像依然在子空间 $\text{im}\boldsymbol{P_1}$ 中，因此结论成立。</p>
<p><strong>从不变子空间到相似三角化</strong></p>
<p>给定方阵 $\boldsymbol{A}$ 和子空间 $\mathbb{W}$ ，求矩阵 $\boldsymbol{P}$ 使得相似矩阵 $\boldsymbol{B}$ 块三角化。</p>
<p>$\Leftrightarrow$ 将 $\mathbb{W}$ 的 $n_1$ 个基向量扩充为 $\mathbb{F}^n$ 的一组基（因为 $\boldsymbol{P}$ 可逆），由这组基组成所求矩阵 $\boldsymbol{P}$ </p>
<p><strong>从相似三角化到不变子空间</strong> </p>
<p>给定矩阵 $\boldsymbol{P}$ ，求不变子空间 $\mathbb{W}$ 。</p>
<p>根据不变子空间的维数 $n_1$ ，取 $\boldsymbol{P}$ 的前 $n_1$ 列向量张成即可。</p>
<h5 id="从一维不变子空间看特征向量"><a href="#从一维不变子空间看特征向量" class="headerlink" title="从一维不变子空间看特征向量"></a>从一维不变子空间看特征向量</h5><p>特征向量满足： $\boldsymbol{A}\boldsymbol{p}=\boldsymbol{p}\lambda,\boldsymbol{A}\in\mathbb{F}^{n\times n},\boldsymbol{p}\in\mathbb{F}^n,\lambda\in\mathbb{F}$ ，显然等式右侧向量也在子空间 $\text{im}\boldsymbol{p}$ 中，所以 $\text{im}\boldsymbol{p}$ 为 $\boldsymbol{A}$ 的一维不变子空间。</p>
<p>即，矩阵的一维不变子空间对应的向量即为特征向量，特征向量对应的特征值可以不只一个。</p>
<h5 id="相似对角化的充要条件"><a href="#相似对角化的充要条件" class="headerlink" title="相似对角化的充要条件"></a>相似对角化的充要条件</h5><p>由上可知，$\boldsymbol{P}=[\boldsymbol{p}_1\ \cdots \ \boldsymbol{p}_n]$ ，因此：</p>
<p>可以相似对角化 $\Leftrightarrow\forall j,\ \text{im}\boldsymbol{p}_j$ 是 $\boldsymbol{A}$ 的不变子空间 $\Leftrightarrow\forall j,\boldsymbol{p}_j$ 是 $\boldsymbol{A}$ 的特征向量 $\Leftrightarrow$ 矩阵 $\boldsymbol{A}$ 有 $n$ 个线性无关的特征向量 $\Leftrightarrow$ 矩阵 $\boldsymbol{A}$ 有一组由特征向量构成的基</p>
<p><strong>从几何角度理解相似对角化</strong>，上述结论也是显然的：</p>
<script type="math/tex; mode=display">
\begin{align}
\boldsymbol{P}^{-1}\boldsymbol{AP}=\boldsymbol{\Lambda}&\Leftrightarrow\boldsymbol{AP}=\boldsymbol{P\Lambda} \notag \\

&\Leftrightarrow\boldsymbol{A}[\boldsymbol{p}_1\cdots\boldsymbol{p}_n]=[\boldsymbol{p}_1\cdots\boldsymbol{p}_n]
\begin{bmatrix}
\lambda_1 & \cdots & 0 \\
\vdots    & \ddots & \vdots \\
0          & \cdots & \lambda_n
\end{bmatrix} \\

&\Leftrightarrow\forall j,\boldsymbol{A}\boldsymbol{p}_j=\boldsymbol{p}_j\lambda_j \notag
\end{align}</script><h5 id="从相似最简型问题到-lambda-矩阵的Jordan标准型"><a href="#从相似最简型问题到-lambda-矩阵的Jordan标准型" class="headerlink" title="从相似最简型问题到$\lambda$ 矩阵的Jordan标准型"></a>从相似最简型问题到$\lambda$ 矩阵的Jordan标准型</h5><p>并不是所有矩阵都有 $n$ 个特征向量，即并不是所有矩阵都能相似对角化，对于不能相似对角化的矩阵，我们提出 <code>Jordan(若当)标准型</code> 的概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">稀疏矩阵操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-27 01:38:41 / 修改时间：01:48:33" itemprop="dateCreated datePublished" datetime="2021-05-27T01:38:41+08:00">2021-05-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/" class="post-title-link" itemprop="url">线性代数与稠密矩阵分解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 21:57:47" itemprop="dateCreated datePublished" datetime="2021-05-24T21:57:47+08:00">2021-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 01:20:54" itemprop="dateModified" datetime="2021-05-27T01:20:54+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍如何利用不同的矩阵分解方法（LU，QR，SVD，特征分解等）求解线性系统</p>
<h4 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h4><p>矩阵分解（decomposition/factorization）是指将矩阵拆分为若干矩阵的乘积，包括三角分解（LU）、满秩分解、QR分解、Jordan分解和奇异值分解（SVD）等。Eigen提供了常用的三种矩阵分解：LU、QR、SVD</p>
<h5 id="三角分解-LU"><a href="#三角分解-LU" class="headerlink" title="三角分解 LU"></a>三角分解 LU</h5><script type="math/tex; mode=display">
A=LU</script><p>将原方阵（square matrix）分解成一个上三角矩阵和一个下三角形矩阵。主要用于简化一个大矩阵的行列式的计算、求逆矩阵、求解方程组。这种分解法所得到的上下三角形矩阵并非唯一。</p>
<h5 id="LLT分解（Cholesky分解）"><a href="#LLT分解（Cholesky分解）" class="headerlink" title="LLT分解（Cholesky分解）"></a>LLT分解（Cholesky分解）</h5><p>若A为<strong>正定矩阵</strong>，则A有如下唯一的分解形式：</p>
<script type="math/tex; mode=display">
A=LL^*</script><p>其中 $L$ 为下三角矩阵，$L^<em>$ 为其共轭转置矩阵，当A为实矩阵时，$L^</em>=L^T$ </p>
<h5 id="LDLT分解"><a href="#LDLT分解" class="headerlink" title="LDLT分解"></a>LDLT分解</h5><p>若A为一<strong>对称矩阵</strong>且其任意<strong>k阶主子阵均不为零</strong>，即半正定或半负定，则A有如下惟一的分解形式：</p>
<script type="math/tex; mode=display">
A=LDL^T</script><p>其中 $L$ 为下三角形单位矩阵（即主对角线元素皆为1），$D$ 为对角矩阵，$L^T$ 为 $L$ 的转置矩阵。LDLT分解法是Cholesky分解法的改进，Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题，可用于求解线性方程组。</p>
<h5 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h5><p>对列向量线性无关的矩阵 A ：</p>
<script type="math/tex; mode=display">
A=QR</script><p>其中，$Q$ 为 $m\times m$ 的酉矩阵（实数域内称为正交矩阵），$R$ 为上三角矩阵</p>
<h5 id="奇异值分解-SVD"><a href="#奇异值分解-SVD" class="headerlink" title="奇异值分解 SVD"></a>奇异值分解 SVD</h5><p>对任意矩阵 A：</p>
<script type="math/tex; mode=display">
A=U\Sigma V^*</script><p>其中 $U$ 和 $V$ 均为酉矩阵（实数域内称为正交矩阵，$V^*=V^T$）且不唯一， $\Sigma$ 为对角矩阵，对角线上的元素称为A的奇异值。用于解最小二乘和数据压缩。</p>
<h4 id="用矩阵分解求解线性方程组"><a href="#用矩阵分解求解线性方程组" class="headerlink" title="用矩阵分解求解线性方程组"></a>用<a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__TopicLinearAlgebraDecompositions.html">矩阵分解</a>求解线性方程组</h4><p>Eigen为矩阵提供了如图所示的分解方法，调用第二列的方法后会返回一个第一列对应的类对象，再通过调用该对象的 <code>solve()</code> 方法实现对方程的求解，具体见后文代码示例。</p>
<p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210526224931096.png" alt="矩阵分解函数"></p>
<h5 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h5><ul>
<li><p><strong>partialPivLu()</strong></p>
<p>基于部分消元的LU分解（必须是可逆方阵）。$A=PLU$ ，其中 $L$ 为单位下三角矩阵，$U$ 为上三角矩阵，$P$ 为置换矩阵，即只进行行变换</p>
</li>
<li><p><strong>fullPivLu()</strong></p>
<p>基于全消元的LU分解（对任意矩阵）。$A=P^{-1}LUQ^{-1}$ ，$L,U,P$ 同上，$Q$ 为置换矩阵，即同时进行行变换和列变换。速度比部分消元慢</p>
</li>
<li><p><strong>llt()</strong></p>
<p>标准Cholesky分解（必须是对称正定矩阵）。$A=LL^*$</p>
</li>
<li><p><strong>ldlt()</strong> </p>
<p>有主元的鲁棒Cholesky分解（必须是半正定或半负定矩阵）。$A=P^TLDL^*P$ </p>
</li>
</ul>
<h5 id="QR-分解"><a href="#QR-分解" class="headerlink" title="QR 分解"></a>QR 分解</h5><ul>
<li><p><strong>householderQr()</strong> </p>
<p>使用 <code>Househoder</code> 变换实现 $A=QR$ 的分解，其中 $Q$ 为酉矩阵，$R$ 为上三角矩阵。无主元，快，但不稳定</p>
</li>
<li><p><strong>colPivHouseholderQr()</strong> </p>
<p>基于行变换（列主元消元法）的 <code>Householder</code> 变换，$AP=QR$ 。较慢，但更精确</p>
</li>
<li><p><strong>fullPivHouseholderQr()</strong> </p>
<p>同时进行行变换和列变换的 <code>Householder</code> 变换，$PAP’=QR$ 。最慢，但最稳定</p>
</li>
<li><p><strong>completeOrthogonalDecomposition()</strong> </p>
<p>完全正交分解。可以看作是QR分解的推广</p>
</li>
</ul>
<h5 id="SVD-分解"><a href="#SVD-分解" class="headerlink" title="SVD 分解"></a>SVD 分解</h5><ul>
<li><p><strong>bdcSvd()</strong> </p>
<p>最快的SVD算法（推荐使用）</p>
</li>
<li><p><strong>jacobiSvd()</strong> </p>
<p>对小矩阵速度快，大矩阵慢</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__DenseDecompositionBenchmark.html">表格</a>给出了上述所有分解方法的效率对比 </p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Eigen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* 假设矩阵A为方阵，待求解方程为 Ax=b */</span></span><br><span class="line">     <span class="comment">// 首先定义一个随机矩阵A，随机列向量b和待求解向量x</span></span><br><span class="line">     MatrixXd A;</span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; b;</span><br><span class="line">     A = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, MATRIX_SIZE);</span><br><span class="line">     b = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 定义时间变量，方便比较效率</span></span><br><span class="line">     <span class="keyword">clock_t</span> <span class="keyword">start_t</span>;</span><br><span class="line">     <span class="keyword">double</span> time;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法一：直接右乘A的逆矩阵 x = A^&#123;-1&#125;*b */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_inv;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_inv = A.<span class="built_in">inverse</span>()*b;</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_inv time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_inv = &quot;</span> &lt;&lt; x_inv.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法二：普通LU分解 </span></span><br><span class="line"><span class="comment">      * Eigen 提供了四种LU分解的方法</span></span><br><span class="line"><span class="comment">      * - partialPivLu(): A = PLU -&gt; 要求A必须可逆</span></span><br><span class="line"><span class="comment">      * - fullPivLu(): A = P^&#123;-1&#125;LUQ^&#123;-1&#125;</span></span><br><span class="line"><span class="comment">      * - llt(): A = LL^T -&gt; 要求A必须对称正定</span></span><br><span class="line"><span class="comment">      * - ldlt(): A = LDL^T -&gt; 要求A必须半正定或半负定</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 2.1 partialPivLu()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_plu;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_plu = A.<span class="built_in">partialPivLu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_plu time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_plu = &quot;</span> &lt;&lt; x_plu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 2.2 fullPivLu()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_flu;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_flu = A.<span class="built_in">fullPivLu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_flu time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_flu = &quot;</span> &lt;&lt; x_flu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法三：LLT分解 */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_llt;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="comment">// 因为llt分解要求 A 必须为正定矩阵，所以构造新的方程：(A^T*A)*x = A^T*b 来求解x</span></span><br><span class="line">     x_llt = (A.<span class="built_in">transpose</span>()*A).<span class="built_in">llt</span>().<span class="built_in">solve</span>(A.<span class="built_in">transpose</span>()*b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_llt time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_llt = &quot;</span> &lt;&lt; x_llt.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法四：LDLT分解 */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_ldlt;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_ldlt = (A.<span class="built_in">transpose</span>()*A).<span class="built_in">llt</span>().<span class="built_in">solve</span>(A.<span class="built_in">transpose</span>()*b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_ldlt time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_ldlt = &quot;</span> &lt;&lt; x_ldlt.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法五：QR分解</span></span><br><span class="line"><span class="comment">      * Eigen 提供了四种QR分解的方法</span></span><br><span class="line"><span class="comment">      * - householderQr()</span></span><br><span class="line"><span class="comment">      * - colPivHouseholderQr()</span></span><br><span class="line"><span class="comment">      * - fullPivHouseholderQr()</span></span><br><span class="line"><span class="comment">      * - completeOrthogonalDecomposition()</span></span><br><span class="line"><span class="comment">      * 常用2和3</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 5.1 colPivHhouseholderQr()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_cqr;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_cqr = A.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_cqr time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_cqr = &quot;</span> &lt;&lt; x_cqr.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 5.2 fullPivHhouseholderQr()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_fqr;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_fqr = A.<span class="built_in">fullPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_fqr time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_fqr = &quot;</span> &lt;&lt; x_plu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法六：SVD分解</span></span><br><span class="line"><span class="comment">      * Eigen 提供了两种SVD分解方法</span></span><br><span class="line"><span class="comment">      * - bdcSvd()</span></span><br><span class="line"><span class="comment">      * - jacobiSvd()</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 6.1 bdcSvd()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_bsvd;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_bsvd = A.<span class="built_in">bdcSvd</span>(ComputeThinU|ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_bsvd time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_bsvd = &quot;</span> &lt;&lt; x_bsvd.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 6.2 jacobiSvd()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_jsvd;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_jsvd = A.<span class="built_in">jacobiSvd</span>(ComputeThinU|ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_jsvd time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_jsvd = &quot;</span> &lt;&lt; x_jsvd.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算结果：</p>
<p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210526224615007.png" alt="计算结果"></p>
<h4 id="计算特征值与特征向量"><a href="#计算特征值与特征向量" class="headerlink" title="计算特征值与特征向量"></a>计算特征值与特征向量</h4><p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210527002238291.png" alt="image-20210527002238291"></p>
<p>如图，Eigen为矩阵提供了四种<strong>特征分解</strong>的方法，第二列表示适用矩阵的条件，第三四列分别表示运算速度和精度</p>
<p>以 <code>SelfAdjointEigenSolver</code> 为例，代码如下，其中 <code>info()</code> 函数用来检查特征值/特征向量是否收敛：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2f A;</span><br><span class="line">   A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   <span class="function">SelfAdjointEigenSolver&lt;Matrix2f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() != Success) <span class="built_in">abort</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The eigenvalues of A are:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here&#x27;s a matrix whose columns are eigenvectors of A \n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;corresponding to these eigenvalues:\n&quot;</span></span><br><span class="line">        &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">The eigenvalues of A are:</span><br><span class="line">-0.236</span><br><span class="line">  4.24</span><br><span class="line">Here<span class="string">&#x27;s a matrix whose columns are eigenvectors of A </span></span><br><span class="line"><span class="string">corresponding to these eigenvalues:</span></span><br><span class="line"><span class="string">-0.851 -0.526</span></span><br><span class="line"><span class="string"> 0.526 -0.851</span></span><br></pre></td></tr></table></figure>
<h4 id="计算逆矩阵与行列式"><a href="#计算逆矩阵与行列式" class="headerlink" title="计算逆矩阵与行列式"></a>计算逆矩阵与行列式</h4><p>尽管逆和行列式是基本的数学概念，但它们在数值线性代数中不像在纯数学中那么常用。求逆通常由 <code>solve()</code> 代替，而行列式一般并不是检测矩阵是否可逆的好方法。不过对于比较小的矩阵，逆和行列式还是比较有用的。</p>
<p>尽管Eigen提供了上述矩阵分解的方法，我们仍然可以直接调用 <code>inverse()</code> 方法和 <code>determinant()</code> 方法。若矩阵尺寸较小（不超过4x4），那么Eigen可以避免使用LU分解，而是使用数学公式，这样更高效。</p>
<h4 id="求解最小二乘"><a href="#求解最小二乘" class="headerlink" title="求解最小二乘"></a><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__LeastSquares.html">求解最小二乘</a></h4><p>求解最小二乘最精确的方法是使用SVD分解。Eigen提供了两种方法（见上文），推荐使用 <code>bdcSvd()</code> ，对大规模问题友好，同时对小规模问题能自动降级到 <code>jacobiSvd()</code> 方法；</p>
<p>另一种方法是使用 <code>Cholesky</code> 分解或 <code>QR</code> 分解，速度可能会快点，但准确率会下降；</p>
<p>第三种方法是将方程转化为 $A^TAx=A^Tb$ 并使用 <code>ldlt()</code> 方法求解。不过，如果 A 是一个病态矩阵的话，这种方法就不会太好，因为 $A^TA$ 的条件数是 $A$ 的平方，这意味着这种方法会比其他方法损失两倍数值。</p>
<h4 id="将求解和构造分开"><a href="#将求解和构造分开" class="headerlink" title="将求解和构造分开"></a>将求解和构造分开</h4><p>上面的例子将矩阵分解对象的构造和计算写在同一句中，当然也有方法将它们分开写，每种矩阵分解类都有一个默认的构造函数和一个 <code>compute(matrix)</code> 方法，该方法可以对不同的 <code>matrix</code> 重复调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2f A, b;</span><br><span class="line">   LLT&lt;Matrix2f&gt; llt;</span><br><span class="line">   A &lt;&lt; <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>;</span><br><span class="line">   b &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</span><br><span class="line">   llt.<span class="built_in">compute</span>(A);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The solution is:\n&quot;</span> &lt;&lt; llt.<span class="built_in">solve</span>(b) &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">A</span>(<span class="number">1</span>,<span class="number">1</span>)++;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The matrix A is now:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</span><br><span class="line">   llt.<span class="built_in">compute</span>(A);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The solution is now:\n&quot;</span> &lt;&lt; llt.<span class="built_in">solve</span>(b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line"> 2 -1</span><br><span class="line">-1  3</span><br><span class="line">Here is the right hand side b:</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">Computing LLT decomposition...</span><br><span class="line">The solution is:</span><br><span class="line">1.2 1.4</span><br><span class="line">1.4 0.8</span><br><span class="line">The matrix A is now:</span><br><span class="line"> 2 -1</span><br><span class="line">-1  4</span><br><span class="line">Computing LLT decomposition...</span><br><span class="line">The solution is now:</span><br><span class="line">    1  1.29</span><br><span class="line">    1 0.571</span><br></pre></td></tr></table></figure>
<p>也可以通过向构造函数中传入矩阵大小来预分配分解矩阵所需要的内存空间大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HouseholderQR&lt;MatrixXf&gt; <span class="title">qr</span><span class="params">(<span class="number">50</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line">MatrixXf A = MatrixXf::<span class="built_in">Random</span>(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">qr.<span class="built_in">compute</span>(A); <span class="comment">// no dynamic memory allocation</span></span><br></pre></td></tr></table></figure>
<h4 id="秩显式分解"><a href="#秩显式分解" class="headerlink" title="秩显式分解"></a>秩显式分解</h4><p>某些分解方法可以同时计算出矩阵的秩，这些通常也是在面对非满秩矩阵（方阵时称为奇异矩阵）时表现最好的方法。包括 <code>FullPivLU</code> 、<code>ColPivHouseholderQR</code> 、<code>FullPivHouseholderQR</code> 、<code>BDCSVD</code> 、<code>JacobiSVD</code> 、<code>SelfAdjointEigenSolver</code> 、<code>ComplexEigenSolver</code> 和 <code>EigenSolver</code> </p>
<p>这些分解类至少提供了一个 <code>rank()</code> 方法用来求矩阵的秩。此外，还提供了一些方便的方法，例如 <code>isInvertible()</code> ；有些还提供了计算矩阵的内核(零空间)和图像(列空间)方法，例如 <code>FullPivLU</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix3f A;</span><br><span class="line">   A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   <span class="function">FullPivLU&lt;Matrix3f&gt; <span class="title">lu_decomp</span><span class="params">(A)</span></span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The rank of A is &quot;</span> &lt;&lt; lu_decomp.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is a matrix whose columns form a basis of the null-space of A:\n&quot;</span></span><br><span class="line">        &lt;&lt; lu_decomp.<span class="built_in">kernel</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is a matrix whose columns form a basis of the column-space of A:\n&quot;</span></span><br><span class="line">        &lt;&lt; lu_decomp.<span class="built_in">image</span>(A) &lt;&lt; endl; <span class="comment">// yes, have to pass the original A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br><span class="line">3 0 3</span><br><span class="line">The rank of A is 2</span><br><span class="line">Here is a matrix whose columns form a basis of the null-space of A:</span><br><span class="line"> 0.5</span><br><span class="line">   1</span><br><span class="line">-0.5</span><br><span class="line">Here is a matrix whose columns form a basis of the column-space of A:</span><br><span class="line">5 1</span><br><span class="line">4 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>当然，任何秩计算都取决于对随机阈值的选择，因为实际上没有哪个浮点矩阵是完全秩亏的。Eigen会选择一个合理的默认阈值。我们也可以自己设定想要的正确阈值：在调用 <code>rank()</code> 或任何其他需要使用这个阈值的方法之前，调用 <code>setThreshold()</code> 来设置阈值。分解计算本身，即 <code>compute()</code> 方法，与阈值选取无关，所以在改变阈值之后，不需要重新计算矩阵分解。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2d A;</span><br><span class="line">   A &lt;&lt; <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">0.9999999999</span>;</span><br><span class="line">   <span class="function">FullPivLU&lt;Matrix2d&gt; <span class="title">lu</span><span class="params">(A)</span></span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;By default, the rank of A is found to be &quot;</span> &lt;&lt; lu.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">   lu.<span class="built_in">setThreshold</span>(<span class="number">1e-5</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;With threshold 1e-5, the rank of A is found to be &quot;</span> &lt;&lt; lu.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">By default, the rank of A is found to be 2</span><br><span class="line">With threshold 1e-5, the rank of A is found to be 1</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="潘薇鸿"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">潘薇鸿</p>
  <div class="site-description" itemprop="description">跬步千里</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WeihongPan" title="GitHub → https://github.com/WeihongPan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘薇鸿</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
