<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weihongpan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"mac","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="跬步千里">
<meta property="og:type" content="website">
<meta property="og:title" content="潘薇鸿">
<meta property="og:url" content="https://weihongpan.github.io/page/2/index.html">
<meta property="og:site_name" content="潘薇鸿">
<meta property="og:description" content="跬步千里">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="潘薇鸿">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://weihongpan.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>潘薇鸿</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">潘薇鸿</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">keep on fighting</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/WeihongPan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/" class="post-title-link" itemprop="url">线性代数与稠密矩阵分解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 21:57:47" itemprop="dateCreated datePublished" datetime="2021-05-24T21:57:47+08:00">2021-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 01:20:54" itemprop="dateModified" datetime="2021-05-27T01:20:54+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍如何利用不同的矩阵分解方法（LU，QR，SVD，特征分解等）求解线性系统</p>
<h4 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h4><p>矩阵分解（decomposition/factorization）是指将矩阵拆分为若干矩阵的乘积，包括三角分解（LU）、满秩分解、QR分解、Jordan分解和奇异值分解（SVD）等。Eigen提供了常用的三种矩阵分解：LU、QR、SVD</p>
<h5 id="三角分解-LU"><a href="#三角分解-LU" class="headerlink" title="三角分解 LU"></a>三角分解 LU</h5><script type="math/tex; mode=display">
A=LU</script><p>将原方阵（square matrix）分解成一个上三角矩阵和一个下三角形矩阵。主要用于简化一个大矩阵的行列式的计算、求逆矩阵、求解方程组。这种分解法所得到的上下三角形矩阵并非唯一。</p>
<h5 id="LLT分解（Cholesky分解）"><a href="#LLT分解（Cholesky分解）" class="headerlink" title="LLT分解（Cholesky分解）"></a>LLT分解（Cholesky分解）</h5><p>若A为<strong>正定矩阵</strong>，则A有如下唯一的分解形式：</p>
<script type="math/tex; mode=display">
A=LL^*</script><p>其中 $L$ 为下三角矩阵，$L^<em>$ 为其共轭转置矩阵，当A为实矩阵时，$L^</em>=L^T$ </p>
<h5 id="LDLT分解"><a href="#LDLT分解" class="headerlink" title="LDLT分解"></a>LDLT分解</h5><p>若A为一<strong>对称矩阵</strong>且其任意<strong>k阶主子阵均不为零</strong>，即半正定或半负定，则A有如下惟一的分解形式：</p>
<script type="math/tex; mode=display">
A=LDL^T</script><p>其中 $L$ 为下三角形单位矩阵（即主对角线元素皆为1），$D$ 为对角矩阵，$L^T$ 为 $L$ 的转置矩阵。LDLT分解法是Cholesky分解法的改进，Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题，可用于求解线性方程组。</p>
<h5 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h5><p>对列向量线性无关的矩阵 A ：</p>
<script type="math/tex; mode=display">
A=QR</script><p>其中，$Q$ 为 $m\times m$ 的酉矩阵（实数域内称为正交矩阵），$R$ 为上三角矩阵</p>
<h5 id="奇异值分解-SVD"><a href="#奇异值分解-SVD" class="headerlink" title="奇异值分解 SVD"></a>奇异值分解 SVD</h5><p>对任意矩阵 A：</p>
<script type="math/tex; mode=display">
A=U\Sigma V^*</script><p>其中 $U$ 和 $V$ 均为酉矩阵（实数域内称为正交矩阵，$V^*=V^T$）且不唯一， $\Sigma$ 为对角矩阵，对角线上的元素称为A的奇异值。用于解最小二乘和数据压缩。</p>
<h4 id="用矩阵分解求解线性方程组"><a href="#用矩阵分解求解线性方程组" class="headerlink" title="用矩阵分解求解线性方程组"></a>用<a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__TopicLinearAlgebraDecompositions.html">矩阵分解</a>求解线性方程组</h4><p>Eigen为矩阵提供了如图所示的分解方法，调用第二列的方法后会返回一个第一列对应的类对象，再通过调用该对象的 <code>solve()</code> 方法实现对方程的求解，具体见后文代码示例。</p>
<p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210526224931096.png" alt="矩阵分解函数"></p>
<h5 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h5><ul>
<li><p><strong>partialPivLu()</strong></p>
<p>基于部分消元的LU分解（必须是可逆方阵）。$A=PLU$ ，其中 $L$ 为单位下三角矩阵，$U$ 为上三角矩阵，$P$ 为置换矩阵，即只进行行变换</p>
</li>
<li><p><strong>fullPivLu()</strong></p>
<p>基于全消元的LU分解（对任意矩阵）。$A=P^{-1}LUQ^{-1}$ ，$L,U,P$ 同上，$Q$ 为置换矩阵，即同时进行行变换和列变换。速度比部分消元慢</p>
</li>
<li><p><strong>llt()</strong></p>
<p>标准Cholesky分解（必须是对称正定矩阵）。$A=LL^*$</p>
</li>
<li><p><strong>ldlt()</strong> </p>
<p>有主元的鲁棒Cholesky分解（必须是半正定或半负定矩阵）。$A=P^TLDL^*P$ </p>
</li>
</ul>
<h5 id="QR-分解"><a href="#QR-分解" class="headerlink" title="QR 分解"></a>QR 分解</h5><ul>
<li><p><strong>householderQr()</strong> </p>
<p>使用 <code>Househoder</code> 变换实现 $A=QR$ 的分解，其中 $Q$ 为酉矩阵，$R$ 为上三角矩阵。无主元，快，但不稳定</p>
</li>
<li><p><strong>colPivHouseholderQr()</strong> </p>
<p>基于行变换（列主元消元法）的 <code>Householder</code> 变换，$AP=QR$ 。较慢，但更精确</p>
</li>
<li><p><strong>fullPivHouseholderQr()</strong> </p>
<p>同时进行行变换和列变换的 <code>Householder</code> 变换，$PAP’=QR$ 。最慢，但最稳定</p>
</li>
<li><p><strong>completeOrthogonalDecomposition()</strong> </p>
<p>完全正交分解。可以看作是QR分解的推广</p>
</li>
</ul>
<h5 id="SVD-分解"><a href="#SVD-分解" class="headerlink" title="SVD 分解"></a>SVD 分解</h5><ul>
<li><p><strong>bdcSvd()</strong> </p>
<p>最快的SVD算法（推荐使用）</p>
</li>
<li><p><strong>jacobiSvd()</strong> </p>
<p>对小矩阵速度快，大矩阵慢</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__DenseDecompositionBenchmark.html">表格</a>给出了上述所有分解方法的效率对比 </p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Eigen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* 假设矩阵A为方阵，待求解方程为 Ax=b */</span></span><br><span class="line">     <span class="comment">// 首先定义一个随机矩阵A，随机列向量b和待求解向量x</span></span><br><span class="line">     MatrixXd A;</span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; b;</span><br><span class="line">     A = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, MATRIX_SIZE);</span><br><span class="line">     b = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 定义时间变量，方便比较效率</span></span><br><span class="line">     <span class="keyword">clock_t</span> <span class="keyword">start_t</span>;</span><br><span class="line">     <span class="keyword">double</span> time;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法一：直接右乘A的逆矩阵 x = A^&#123;-1&#125;*b */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_inv;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_inv = A.<span class="built_in">inverse</span>()*b;</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_inv time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_inv = &quot;</span> &lt;&lt; x_inv.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法二：普通LU分解 </span></span><br><span class="line"><span class="comment">      * Eigen 提供了四种LU分解的方法</span></span><br><span class="line"><span class="comment">      * - partialPivLu(): A = PLU -&gt; 要求A必须可逆</span></span><br><span class="line"><span class="comment">      * - fullPivLu(): A = P^&#123;-1&#125;LUQ^&#123;-1&#125;</span></span><br><span class="line"><span class="comment">      * - llt(): A = LL^T -&gt; 要求A必须对称正定</span></span><br><span class="line"><span class="comment">      * - ldlt(): A = LDL^T -&gt; 要求A必须半正定或半负定</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 2.1 partialPivLu()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_plu;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_plu = A.<span class="built_in">partialPivLu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_plu time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_plu = &quot;</span> &lt;&lt; x_plu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 2.2 fullPivLu()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_flu;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_flu = A.<span class="built_in">fullPivLu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_flu time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_flu = &quot;</span> &lt;&lt; x_flu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法三：LLT分解 */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_llt;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="comment">// 因为llt分解要求 A 必须为正定矩阵，所以构造新的方程：(A^T*A)*x = A^T*b 来求解x</span></span><br><span class="line">     x_llt = (A.<span class="built_in">transpose</span>()*A).<span class="built_in">llt</span>().<span class="built_in">solve</span>(A.<span class="built_in">transpose</span>()*b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_llt time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_llt = &quot;</span> &lt;&lt; x_llt.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法四：LDLT分解 */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_ldlt;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_ldlt = (A.<span class="built_in">transpose</span>()*A).<span class="built_in">llt</span>().<span class="built_in">solve</span>(A.<span class="built_in">transpose</span>()*b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_ldlt time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_ldlt = &quot;</span> &lt;&lt; x_ldlt.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法五：QR分解</span></span><br><span class="line"><span class="comment">      * Eigen 提供了四种QR分解的方法</span></span><br><span class="line"><span class="comment">      * - householderQr()</span></span><br><span class="line"><span class="comment">      * - colPivHouseholderQr()</span></span><br><span class="line"><span class="comment">      * - fullPivHouseholderQr()</span></span><br><span class="line"><span class="comment">      * - completeOrthogonalDecomposition()</span></span><br><span class="line"><span class="comment">      * 常用2和3</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 5.1 colPivHhouseholderQr()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_cqr;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_cqr = A.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_cqr time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_cqr = &quot;</span> &lt;&lt; x_cqr.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 5.2 fullPivHhouseholderQr()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_fqr;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_fqr = A.<span class="built_in">fullPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_fqr time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_fqr = &quot;</span> &lt;&lt; x_plu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法六：SVD分解</span></span><br><span class="line"><span class="comment">      * Eigen 提供了两种SVD分解方法</span></span><br><span class="line"><span class="comment">      * - bdcSvd()</span></span><br><span class="line"><span class="comment">      * - jacobiSvd()</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 6.1 bdcSvd()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_bsvd;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_bsvd = A.<span class="built_in">bdcSvd</span>(ComputeThinU|ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_bsvd time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_bsvd = &quot;</span> &lt;&lt; x_bsvd.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 6.2 jacobiSvd()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_jsvd;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_jsvd = A.<span class="built_in">jacobiSvd</span>(ComputeThinU|ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_jsvd time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_jsvd = &quot;</span> &lt;&lt; x_jsvd.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算结果：</p>
<p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210526224615007.png" alt="计算结果"></p>
<h4 id="计算特征值与特征向量"><a href="#计算特征值与特征向量" class="headerlink" title="计算特征值与特征向量"></a>计算特征值与特征向量</h4><p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210527002238291.png" alt="image-20210527002238291"></p>
<p>如图，Eigen为矩阵提供了四种<strong>特征分解</strong>的方法，第二列表示适用矩阵的条件，第三四列分别表示运算速度和精度</p>
<p>以 <code>SelfAdjointEigenSolver</code> 为例，代码如下，其中 <code>info()</code> 函数用来检查特征值/特征向量是否收敛：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2f A;</span><br><span class="line">   A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   <span class="function">SelfAdjointEigenSolver&lt;Matrix2f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() != Success) <span class="built_in">abort</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The eigenvalues of A are:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here&#x27;s a matrix whose columns are eigenvectors of A \n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;corresponding to these eigenvalues:\n&quot;</span></span><br><span class="line">        &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">The eigenvalues of A are:</span><br><span class="line">-0.236</span><br><span class="line">  4.24</span><br><span class="line">Here<span class="string">&#x27;s a matrix whose columns are eigenvectors of A </span></span><br><span class="line"><span class="string">corresponding to these eigenvalues:</span></span><br><span class="line"><span class="string">-0.851 -0.526</span></span><br><span class="line"><span class="string"> 0.526 -0.851</span></span><br></pre></td></tr></table></figure>
<h4 id="计算逆矩阵与行列式"><a href="#计算逆矩阵与行列式" class="headerlink" title="计算逆矩阵与行列式"></a>计算逆矩阵与行列式</h4><p>尽管逆和行列式是基本的数学概念，但它们在数值线性代数中不像在纯数学中那么常用。求逆通常由 <code>solve()</code> 代替，而行列式一般并不是检测矩阵是否可逆的好方法。不过对于比较小的矩阵，逆和行列式还是比较有用的。</p>
<p>尽管Eigen提供了上述矩阵分解的方法，我们仍然可以直接调用 <code>inverse()</code> 方法和 <code>determinant()</code> 方法。若矩阵尺寸较小（不超过4x4），那么Eigen可以避免使用LU分解，而是使用数学公式，这样更高效。</p>
<h4 id="求解最小二乘"><a href="#求解最小二乘" class="headerlink" title="求解最小二乘"></a><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__LeastSquares.html">求解最小二乘</a></h4><p>求解最小二乘最精确的方法是使用SVD分解。Eigen提供了两种方法（见上文），推荐使用 <code>bdcSvd()</code> ，对大规模问题友好，同时对小规模问题能自动降级到 <code>jacobiSvd()</code> 方法；</p>
<p>另一种方法是使用 <code>Cholesky</code> 分解或 <code>QR</code> 分解，速度可能会快点，但准确率会下降；</p>
<p>第三种方法是将方程转化为 $A^TAx=A^Tb$ 并使用 <code>ldlt()</code> 方法求解。不过，如果 A 是一个病态矩阵的话，这种方法就不会太好，因为 $A^TA$ 的条件数是 $A$ 的平方，这意味着这种方法会比其他方法损失两倍数值。</p>
<h4 id="将求解和构造分开"><a href="#将求解和构造分开" class="headerlink" title="将求解和构造分开"></a>将求解和构造分开</h4><p>上面的例子将矩阵分解对象的构造和计算写在同一句中，当然也有方法将它们分开写，每种矩阵分解类都有一个默认的构造函数和一个 <code>compute(matrix)</code> 方法，该方法可以对不同的 <code>matrix</code> 重复调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2f A, b;</span><br><span class="line">   LLT&lt;Matrix2f&gt; llt;</span><br><span class="line">   A &lt;&lt; <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>;</span><br><span class="line">   b &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</span><br><span class="line">   llt.<span class="built_in">compute</span>(A);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The solution is:\n&quot;</span> &lt;&lt; llt.<span class="built_in">solve</span>(b) &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">A</span>(<span class="number">1</span>,<span class="number">1</span>)++;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The matrix A is now:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</span><br><span class="line">   llt.<span class="built_in">compute</span>(A);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The solution is now:\n&quot;</span> &lt;&lt; llt.<span class="built_in">solve</span>(b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line"> 2 -1</span><br><span class="line">-1  3</span><br><span class="line">Here is the right hand side b:</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">Computing LLT decomposition...</span><br><span class="line">The solution is:</span><br><span class="line">1.2 1.4</span><br><span class="line">1.4 0.8</span><br><span class="line">The matrix A is now:</span><br><span class="line"> 2 -1</span><br><span class="line">-1  4</span><br><span class="line">Computing LLT decomposition...</span><br><span class="line">The solution is now:</span><br><span class="line">    1  1.29</span><br><span class="line">    1 0.571</span><br></pre></td></tr></table></figure>
<p>也可以通过向构造函数中传入矩阵大小来预分配分解矩阵所需要的内存空间大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HouseholderQR&lt;MatrixXf&gt; <span class="title">qr</span><span class="params">(<span class="number">50</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line">MatrixXf A = MatrixXf::<span class="built_in">Random</span>(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">qr.<span class="built_in">compute</span>(A); <span class="comment">// no dynamic memory allocation</span></span><br></pre></td></tr></table></figure>
<h4 id="秩显式分解"><a href="#秩显式分解" class="headerlink" title="秩显式分解"></a>秩显式分解</h4><p>某些分解方法可以同时计算出矩阵的秩，这些通常也是在面对非满秩矩阵（方阵时称为奇异矩阵）时表现最好的方法。包括 <code>FullPivLU</code> 、<code>ColPivHouseholderQR</code> 、<code>FullPivHouseholderQR</code> 、<code>BDCSVD</code> 、<code>JacobiSVD</code> 、<code>SelfAdjointEigenSolver</code> 、<code>ComplexEigenSolver</code> 和 <code>EigenSolver</code> </p>
<p>这些分解类至少提供了一个 <code>rank()</code> 方法用来求矩阵的秩。此外，还提供了一些方便的方法，例如 <code>isInvertible()</code> ；有些还提供了计算矩阵的内核(零空间)和图像(列空间)方法，例如 <code>FullPivLU</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix3f A;</span><br><span class="line">   A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   <span class="function">FullPivLU&lt;Matrix3f&gt; <span class="title">lu_decomp</span><span class="params">(A)</span></span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The rank of A is &quot;</span> &lt;&lt; lu_decomp.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is a matrix whose columns form a basis of the null-space of A:\n&quot;</span></span><br><span class="line">        &lt;&lt; lu_decomp.<span class="built_in">kernel</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is a matrix whose columns form a basis of the column-space of A:\n&quot;</span></span><br><span class="line">        &lt;&lt; lu_decomp.<span class="built_in">image</span>(A) &lt;&lt; endl; <span class="comment">// yes, have to pass the original A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br><span class="line">3 0 3</span><br><span class="line">The rank of A is 2</span><br><span class="line">Here is a matrix whose columns form a basis of the null-space of A:</span><br><span class="line"> 0.5</span><br><span class="line">   1</span><br><span class="line">-0.5</span><br><span class="line">Here is a matrix whose columns form a basis of the column-space of A:</span><br><span class="line">5 1</span><br><span class="line">4 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>当然，任何秩计算都取决于对随机阈值的选择，因为实际上没有哪个浮点矩阵是完全秩亏的。Eigen会选择一个合理的默认阈值。我们也可以自己设定想要的正确阈值：在调用 <code>rank()</code> 或任何其他需要使用这个阈值的方法之前，调用 <code>setThreshold()</code> 来设置阈值。分解计算本身，即 <code>compute()</code> 方法，与阈值选取无关，所以在改变阈值之后，不需要重新计算矩阵分解。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2d A;</span><br><span class="line">   A &lt;&lt; <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">0.9999999999</span>;</span><br><span class="line">   <span class="function">FullPivLU&lt;Matrix2d&gt; <span class="title">lu</span><span class="params">(A)</span></span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;By default, the rank of A is found to be &quot;</span> &lt;&lt; lu.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">   lu.<span class="built_in">setThreshold</span>(<span class="number">1e-5</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;With threshold 1e-5, the rank of A is found to be &quot;</span> &lt;&lt; lu.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">By default, the rank of A is found to be 2</span><br><span class="line">With threshold 1e-5, the rank of A is found to be 1</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E6%B7%B7%E5%8F%A0%E9%97%AE%E9%A2%98-Aliasing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E6%B7%B7%E5%8F%A0%E9%97%AE%E9%A2%98-Aliasing/" class="post-title-link" itemprop="url">混叠问题(Aliasing)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-24 08:25:49 / 修改时间：21:47:10" itemprop="dateCreated datePublished" datetime="2021-05-24T08:25:49+08:00">2021-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>混叠问题指的是在进行赋值操作的时候，赋值表达式的两边存在重叠的矩阵区域，例如 <code>mat = 2*mat;</code> 或 <code>mat = mat.transpose();</code> 。前一个表达式中的混叠问题不会对结果产生影响，但后一个表达式中的混叠问题会导致不可预料的结果。本节将解释什么是混叠问题，何时有害，如何处理。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXi <span class="title">mat</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">mat.<span class="built_in">bottomRightCorner</span>(<span class="number">2</span>,<span class="number">2</span>) = mat.<span class="built_in">topLeftCorner</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After the assignment:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mat:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">After the assignment: </span><br><span class="line">1 2 3</span><br><span class="line">4 1 2</span><br><span class="line">7 4 1</span><br></pre></td></tr></table></figure>
<p>可见，输出并不像我们所期望的一样将左上角的 $2\times2$ 子矩阵赋值给右下角的 $2\times2$ 子矩阵，这种情况正是由混叠问题引起的，赋值表达式的两端存在重叠的矩阵区域，即 $mat(1,1)$ 。之所以会造成这个问题，是因为Eigen中的赋值操作采用了<strong>延迟计算</strong>（也称惰性计算，Lazy Evaluation），即赋值运算并不会马上执行，而是在用到该变量时才进行计算，上述赋值运算等价于如下过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">mat</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">2</span>) = <span class="built_in">mat</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">mat</span>(<span class="number">2</span>,<span class="number">1</span>) = <span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">mat</span>(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>所以，在为 <code>mat(2,2)</code> 赋值时，<code>mat(1,1)</code> 已经不再是旧的值，而已经被赋上了新的值。</p>
<p>尝试进行矩阵压缩的时候很容易出现混叠问题，例如 <code>vec = vec.head(n);</code> 或 <code>mat = mat.block(i,j,row,col);</code> 等。</p>
<p>通常情况下，混叠问题在编译过程中是不会被识别出来的，但运行时会以异常信息 (run-time assertion) 做出提示，可以使用 <code>EIGEN_NO_DEBUG</code> 退出debug模式关闭异常提示，但最好不要。</p>
<h4 id="如何解决混叠问题"><a href="#如何解决混叠问题" class="headerlink" title="如何解决混叠问题"></a>如何解决混叠问题</h4><p>显然，最简单的解决方法就是把右侧的计算结果赋给一个临时变量，计算结束后再将这个临时变量赋值给左侧的变量，Eigen中使用 <code>eval()</code> 函数实现。用 <code>eval()</code> 纠正上例中出现的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXi <span class="title">mat</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">mat.<span class="built_in">bottomRightCorner</span>(<span class="number">2</span>,<span class="number">2</span>) = mat.<span class="built_in">topLeftCorner</span>(<span class="number">2</span>,<span class="number">2</span>).<span class="built_in">eval</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After the assignment:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mat:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">After the assignment: </span><br><span class="line">1 2 3</span><br><span class="line">4 1 2</span><br><span class="line">7 4 5</span><br></pre></td></tr></table></figure>
<p>又例如对矩阵作转置时，直接使用 <code>a = a.transpose();</code> 会导致混叠问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix2i a; a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">a = a.<span class="built_in">transpose</span>(); <span class="comment">// !!! do NOT do this !!!</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Transposed a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix a:</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">Transposed a:</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p>与上面相同的解决方法，即使用 <code>a = a.transpose().eval()</code> 代替。此外，Eigen提供了一种专门针对这种情况的特殊函数 <code>transposeInPlace()</code> 以实现将当前矩阵替换为其转置矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>; a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the initial matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a.<span class="built_in">transposeInPlace</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;and after being transposed:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Here is the initial matrix a:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">and after being transposed:</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure>
<p>类似的原地处理函数还有：</p>
<ul>
<li><code>MatrixBase::adjoint()</code> &lt;-&gt; <code>MatrixBase::adjointInPlace()</code></li>
<li><code>DenseBase::reverse()</code> &lt;-&gt; <code>DenseBase::reverseInPlace()</code></li>
<li><code>LDLT::solve()</code> &lt;-&gt; <code>LDLT::solveInPlace()</code></li>
<li><code>LLT::solve()</code> &lt;-&gt; <code>LLT::solveInPlace()</code></li>
<li><code>TriangularView::solve()</code> &lt;-&gt; <code>TriangularView::solveInPlace()</code></li>
<li><code>DenseBase::transpose()</code> &lt;-&gt; <code>DenseBase::transposeInPlace()</code></li>
</ul>
<p>针对矩阵/向量压缩处理（取几行几列/取前几个元素），例如 <code>vec = vec.head(n)</code> ，可以使用 <code>conservativeResize()</code> 实现原地处理。</p>
<h4 id="混叠问题与元素级操作"><a href="#混叠问题与元素级操作" class="headerlink" title="混叠问题与元素级操作"></a>混叠问题与元素级操作</h4><p>在元素级操作中，尽管赋值表达式两边也有可能出现同一个矩阵（例如矩阵加法，数组乘法，标量乘法等），但不会对结果产生影响，即元素级操作中的混叠是安全的，因此也就不需要 <code>eval()</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>; </span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,  <span class="number">4</span>, <span class="number">7</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">mat = <span class="number">2</span> * mat;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After &#x27;mat = 2 * mat&#x27;, mat = \n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mat = mat - MatrixXf::<span class="built_in">Identity</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After the subtraction, it becomes\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ArrayXXf arr = mat;</span><br><span class="line">arr = arr.<span class="built_in">square</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After squaring, it becomes\n&quot;</span> &lt;&lt; arr &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Combining all operations in one statement:</span></span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,  <span class="number">4</span>, <span class="number">7</span>;</span><br><span class="line">mat = (<span class="number">2</span> * mat - MatrixXf::<span class="built_in">Identity</span>(<span class="number">2</span>,<span class="number">2</span>)).<span class="built_in">array</span>().<span class="built_in">square</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Doing everything at once yields\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix mat:</span><br><span class="line">1 2</span><br><span class="line">4 7</span><br><span class="line"></span><br><span class="line">After <span class="string">&#x27;mat = 2 * mat&#x27;</span>, mat = </span><br><span class="line"> 2  4</span><br><span class="line"> 8 14</span><br><span class="line"></span><br><span class="line">After the subtraction, it becomes</span><br><span class="line"> 1  4</span><br><span class="line"> 8 13</span><br><span class="line"></span><br><span class="line">After squaring, it becomes</span><br><span class="line">  1  16</span><br><span class="line"> 64 169</span><br><span class="line"></span><br><span class="line">Doing everything at once yields</span><br><span class="line">  1  16</span><br><span class="line"> 64 169</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总而言之，当表达式右侧的 <code>(i,j)</code> 元素仅仅依赖于表达式左侧对应的 <code>(i,j)</code> 元素时，赋值操作是安全的，也就不再需要多余的 <code>eval()</code> 操作。</strong></p>
<h4 id="混叠问题与矩阵乘法"><a href="#混叠问题与矩阵乘法" class="headerlink" title="混叠问题与矩阵乘法"></a>混叠问题与矩阵乘法</h4><p>在目标矩阵未调整大小的情况下，矩阵乘法是Eigen中唯一默认进行混叠处理的操作。换言之，若矩阵 <code>matA</code> 为平方型矩阵（<strong>行数 = 列数</strong>），则赋值语句 <code>matA = matA*matA</code> 是安全的。</p>
<p>除此之外的所有操作，Eigen都默认不存在由混叠导致的错误，要么是因为结果被赋值给了一个不同的矩阵，要么是因为当前进行的是元素级操作。</p>
<p>不过Eigen对矩阵乘法进行的这种处理是需要付出一定计算资源的代价的。在进行上述乘法的过程中，Eigen首先将乘积计算入一个临时矩阵，结束计算后再将这个临时矩阵赋值给 <code>matA</code> ，在当前情况下这是合理的。但相同的操作也会对 <code>matB = matA * matA</code> 进行，这就会导致一定程度上的计算资源浪费。在这种情况下，Eigen提供了 <code>noalias()</code> 函数进行直接赋值而不用经过中间的临时矩阵：<code>matB.noalias() = matA * matA</code> 。这种操作一定要<strong>慎用！！！</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当表达式两端同时出现相同的矩阵/数组时会出现混叠</p>
<ul>
<li>元素级操作时无害，包括标量/数组乘法和矩阵/数组加法</li>
<li>两个行列相等的矩阵相乘，Eigen默认进行混叠处理；若明确不会出现混叠，使用 <code>noalias()</code> </li>
<li>其他情况下Eigen默认不进行混叠处理，因此容易在某些情况下产生错误答案。使用 <code>eval()</code> 或 <code>xxxInPlace()</code> 函数来避免此类情况</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E5%8F%98%E5%BD%A2%E4%B8%8E%E5%88%86%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E5%8F%98%E5%BD%A2%E4%B8%8E%E5%88%86%E7%89%87/" class="post-title-link" itemprop="url">变形与切片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 17:10:44" itemprop="dateCreated datePublished" datetime="2021-04-23T17:10:44+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-11 16:00:58" itemprop="dateModified" datetime="2021-05-11T16:00:58+08:00">2021-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Eigen 尚未提供显式方法实现变形与切片，但可以用Map类模拟实现</p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>变形指的是在保持原有矩阵系数不变的情况下，调整矩阵的行列大小，Map类提供了一种在原有存储的基础上创建不同矩阵视图的方法，需要注意的是，原矩阵中的数据存储顺序会影响数据在线性视图中的顺序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">Ma</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">M1 &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">	  <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">	  <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;RowVectorXf&gt; <span class="title">v1</span><span class="params">(M1.data(), M1.size())</span></span>; <span class="comment">// M1.data()将按列优先取出数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1:&quot;</span> &lt;&lt; endl &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix&lt;<span class="keyword">float</span>, Dynamic, Dynamic, RowMajor&gt; <span class="title">M2</span><span class="params">(M1)</span></span>;</span><br><span class="line"><span class="function">Map&lt;RowVectorXf&gt; <span class="title">v2</span><span class="params">(M2.data(), M2.size())</span></span>; <span class="comment">// M2.data()将按行优先取出数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2:&quot;</span> &lt;&lt; endl &lt;&lt; v2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1:</span><br><span class="line">1 4 7 2 5 8 3 6 9</span><br><span class="line">v2:</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<ul>
<li>例：2 $\times$ 6 矩阵转置为6 $\times$ 2：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix&lt;<span class="keyword">float</span>, Dynamic, Dynamic, RowMajor&gt; <span class="title">M1</span><span class="params">(<span class="number">2</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">M1 &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">	  <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>;</span><br><span class="line"><span class="function">Map&lt;MatrixXf&gt; <span class="title">M2</span><span class="params">(M1.data(), <span class="number">6</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;M2:&quot;</span> &lt;&lt; endl &lt;&lt; M2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M2:</span><br><span class="line">1  7</span><br><span class="line">2  8</span><br><span class="line">3  9</span><br><span class="line">4 10</span><br><span class="line">5 11</span><br><span class="line">6 12</span><br></pre></td></tr></table></figure>
<p>注意到实现矩阵转置的时候，必须采用行优先保存，否则变形出来的矩阵就不是转置矩阵了！</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片指的是取出矩阵中均匀间隔的行、列或元素</p>
<ul>
<li>例：间隔取出向量中的某些元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RowVectorXf v = RowVectorXf::<span class="built_in">LinSpaced</span>(<span class="number">20</span>,<span class="number">0</span>,<span class="number">19</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">Map&lt;RowVectorXf,<span class="number">0</span>,InnerStride&lt;<span class="number">2</span>&gt; &gt; <span class="built_in">v2</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Even:&quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"> 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19</span><br><span class="line">Even: 0  2  4  6  8 10 12 14 16 18</span><br></pre></td></tr></table></figure>
<ul>
<li>例：根据具体的存储顺序，使用足够的步幅 <code>stride</code> 依次从三列中取出一列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MatrixXf M1 = MatrixXf::<span class="built_in">Random</span>(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Column Major Input:\n&quot;</span></span><br><span class="line">     &lt;&lt; M1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Map&lt;MatrixXf, <span class="number">0</span>, OuterStride&lt;&gt;&gt; <span class="built_in">M2</span>(</span><br><span class="line">    M1.<span class="built_in">data</span>(), M1.<span class="built_in">rows</span>(), (M1.<span class="built_in">cols</span>() + <span class="number">2</span>) / <span class="number">3</span>,</span><br><span class="line">    OuterStride&lt;&gt;(M1.<span class="built_in">outerStride</span>() * <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 第二个参数 MapOptions=0 即使用默认值Unaligned</span></span><br><span class="line"><span class="comment">// 第三个参数 OuterStride&lt;&gt;说明初始化时只需声明外步幅的大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对列优先矩阵取出每3列中的第1列:\n&quot;</span></span><br><span class="line">     &lt;&lt; M2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="keyword">float</span>, Dynamic, Dynamic, RowMajor&gt; RowMajorMatrixXf;</span><br><span class="line"><span class="function">RowMajorMatrixXf <span class="title">M3</span><span class="params">(M1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row Major Input:\n&quot;</span></span><br><span class="line">     &lt;&lt; M3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Map&lt;RowMajorMatrixXf, <span class="number">0</span>, Stride&lt;Dynamic, <span class="number">3</span>&gt;&gt; <span class="built_in">M4</span>(</span><br><span class="line">    M3.<span class="built_in">data</span>(), M3.<span class="built_in">rows</span>(), (M3.<span class="built_in">cols</span>() + <span class="number">2</span>) / <span class="number">3</span>,</span><br><span class="line">    Stride&lt;Dynamic, <span class="number">3</span>&gt;(M3.<span class="built_in">outerStride</span>(), <span class="number">3</span>)); <span class="comment">// 意味着行间步幅1，列间步幅3</span></span><br><span class="line"><span class="comment">// 第三个参数 Stride&lt;OuterStride&lt;&gt;, InnerStride&lt;&gt;&gt; 指定外步幅和内步幅</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对行优先矩阵取出每3列中的第1列:\n&quot;</span></span><br><span class="line">     &lt;&lt; M4 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Column Major Input:</span><br><span class="line">  0.680375    0.59688  -0.329554    0.10794  -0.270431    0.83239  -0.716795  -0.514226</span><br><span class="line"> -0.211234   0.823295   0.536459 -0.0452059  0.0268018   0.271423   0.213938  -0.725537</span><br><span class="line">  0.566198  -0.604897  -0.444451   0.257742   0.904459   0.434594  -0.967399   0.608353</span><br><span class="line">对列优先矩阵取出每3列中的第1列:</span><br><span class="line">  0.680375    0.10794  -0.716795</span><br><span class="line"> -0.211234 -0.0452059   0.213938</span><br><span class="line">  0.566198   0.257742  -0.967399</span><br><span class="line">Row Major Input:</span><br><span class="line">  0.680375    0.59688  -0.329554    0.10794  -0.270431    0.83239  -0.716795  -0.514226</span><br><span class="line"> -0.211234   0.823295   0.536459 -0.0452059  0.0268018   0.271423   0.213938  -0.725537</span><br><span class="line">  0.566198  -0.604897  -0.444451   0.257742   0.904459   0.434594  -0.967399   0.608353</span><br><span class="line">对行优先矩阵取出每3列中的第1列:</span><br><span class="line">  0.680375    0.10794  -0.716795</span><br><span class="line"> -0.211234 -0.0452059   0.213938</span><br><span class="line">  0.566198   0.257742  -0.967399</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/Map%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%8EC-C++%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/Map%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%8EC-C++%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">Map类实现与C/C++数组的转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 15:24:43 / 修改时间：17:05:18" itemprop="dateCreated datePublished" datetime="2021-04-23T15:24:43+08:00">2021-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍如何使用 <code>Map</code> 类通过不复制数据的方法将原始 C/C++ 数组转换成矩阵或向量</p>
<h3 id="Map类模板参数与构造函数"><a href="#Map类模板参数与构造函数" class="headerlink" title="Map类模板参数与构造函数"></a>Map类模板参数与构造函数</h3><p>Map类模板参数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">int</span> MapOptions = Unaligned, <span class="keyword">typename</span> StrideType&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>MatrixType</code> : <code>required</code> ，声明是哪种类型的矩阵或向量</p>
</li>
<li><p><code>MapOptions</code> : <code>optional</code> ，声明指针是对齐的还是未对齐的</p>
</li>
<li><p><code>StrideType</code> : <code>optional</code> ，使用<a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/classEigen_1_1Stride.html"> <code>Stride</code> 类</a>为内存中的数组自定义布局</p>
<p><code>Stride</code> 类有两个模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stride&lt;OuterStride, InnerStride&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>OuterStride</code> : 指的是 列优先矩阵的两个连续列 或 行优先矩阵的两个连续行 之间的指针增量</li>
<li><code>InnerStride</code> : 指的是 列优先矩阵的某一列内两个连续行 或 行优先矩阵的某一列内两个连续列 之间的指针增量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) array[i] = i;</span><br><span class="line"><span class="comment">// 默认列优先</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Column-major:\n&quot;</span> </span><br><span class="line">     &lt;&lt; Map&lt;Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>&gt; &gt;(array) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过定义矩阵类型实现行优先</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row-major:\n&quot;</span> </span><br><span class="line">     &lt;&lt; Map&lt;Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>,RowMajor&gt; &gt;(array) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过Stride参数实现行优先</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row-major using stride:\n&quot;</span> </span><br><span class="line">     &lt;&lt; Map&lt;Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>&gt;, Unaligned, Stride&lt;<span class="number">1</span>,<span class="number">4</span>&gt; &gt;(array) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Column-major:</span><br><span class="line">0 2 4 6</span><br><span class="line">1 3 5 7</span><br><span class="line">Row-major:</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">Row-major using stride:</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>Stride</code> 类还能更灵活：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i) array[i] = i;</span><br><span class="line">cout &lt;&lt; Map&lt;MatrixXi, <span class="number">0</span>, Stride&lt;Dynamic,<span class="number">2</span>&gt; &gt;</span><br><span class="line">        (array, <span class="number">3</span>, <span class="number">3</span>, Stride&lt;Dynamic,<span class="number">2</span>&gt;(<span class="number">8</span>, <span class="number">2</span>))</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 列间隔8，行间隔2</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0  8 16</span><br><span class="line">2 10 18</span><br><span class="line">4 12 20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在构造一个Map类型对象的时候，还需要另外两个信息：指向数组内存空间的指针；目标矩阵/向量的大小。当矩阵/变量类型为固定大小的类型时，第二个信息可以省略。</p>
<ul>
<li><p>构造一个Map类型的对象用来转换动态大小的 <code>float</code> 矩阵：其中 <code>pf</code> 是一个 <code>float*</code> 类型的指针，指向数组内存空间，<code>rows</code> 和 <code>cols</code> 则定义了目标矩阵的维度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;MatrixXf&gt; <span class="title">mf</span><span class="params">(pf, rows, cols)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造一个Map类型的对象用来转换固定大小的 <code>int</code> 只读向量：其中 <code>pi</code> 是一个 <code>int*</code> 类型的指针，因为 <code>Vector4i</code> 已经说明了向量维度，所以不再需要向构造函数传入向量的维度信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;<span class="keyword">const</span> Vector4i&gt; <span class="title">mi</span><span class="params">(pi)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，Map类并没有默认构造函数，在构造对象的时候，必须告诉构造函数所要转化的数组的地址指针。</p>
<h3 id="Map类型对象的使用"><a href="#Map类型对象的使用" class="headerlink" title="Map类型对象的使用"></a>Map类型对象的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="keyword">float</span>, <span class="number">1</span>, Dynamic&gt; MatrixType;</span><br><span class="line"><span class="keyword">typedef</span> Map&lt;MatrixType&gt; MapType;</span><br><span class="line"><span class="keyword">typedef</span> Map&lt;<span class="keyword">const</span> MatrixType&gt; MapTypeConst; <span class="comment">// a read-only map</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n_dims = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MatrixType <span class="title">m1</span><span class="params">(n_dims)</span>, <span class="title">m2</span><span class="params">(n_dims)</span></span>;</span><br><span class="line">m1.<span class="built_in">setRandom</span>();</span><br><span class="line">m2.<span class="built_in">setRandom</span>();</span><br><span class="line"><span class="keyword">float</span> *p = &amp;<span class="built_in">m2</span>(<span class="number">0</span>); <span class="comment">// 拿到矩阵m2的地址</span></span><br><span class="line"><span class="function">MapType <span class="title">m2map</span><span class="params">(p,m2.size())</span></span>; <span class="comment">// 矩阵m2map和矩阵m2共享内存空间（地址相同）</span></span><br><span class="line"><span class="function">MapTypeConst <span class="title">m2mapconst</span><span class="params">(p, m2.size())</span></span>; <span class="comment">// 通过矩阵m2mapconst只能实现对m2的访问，而不能修改</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m1: &quot;</span> &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2: &quot;</span> &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Squared euclidean distance: &quot;</span> &lt;&lt; (m1-m2).<span class="built_in">squaredNorm</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Squared euclidean distance, using map: &quot;</span> </span><br><span class="line">     &lt;&lt; (m1-m2map).<span class="built_in">squaredNorm</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">m2map</span>(<span class="number">3</span>) = <span class="number">7</span>;   <span class="comment">// 这一步会同时改变m2和m2mapconst的值，因为这三者共享内存空间</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Updated m2: &quot;</span> &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2 coefficient 2, constant accessor: &quot;</span> &lt;&lt; <span class="built_in">m2mapconst</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m1:  0.680375 -0.211234  0.566198   0.59688  0.823295</span><br><span class="line">m2: -0.604897 -0.329554  0.536459 -0.444451   0.10794</span><br><span class="line">Squared euclidean distance: 3.26291</span><br><span class="line">Squared euclidean distance, using map: 3.26291</span><br><span class="line">Updated m2: -0.604897 -0.329554  0.536459         7   0.10794</span><br><span class="line">m2 coefficient 2, constant accessor: 7</span><br></pre></td></tr></table></figure>
<p>虽然Eigen的所有函数都会像接受其他Eigen类型一样接受Map对象，但在实现自己的函数过程中，从Map对象到其对应的Dense类对象的转换并不会自动完成。具体见 <a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html">以Eigen类型为参数编写函数</a> </p>
<h3 id="修改映射数组"><a href="#修改映射数组" class="headerlink" title="修改映射数组"></a>修改映射数组</h3><p>可以使用C++的 <code>placement new</code> 语法实现在生命Map对象后修改其数组。简而言之，<code>placement new</code> 语法实现的是从给定指针所指向的地址开始创建一个新的对象，一般来说该指针指向的是一片提前申请好的内存，所以也不会进行内存分配。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">Map&lt;RowVectorXi&gt; <span class="title">v</span><span class="params">(data,<span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The mapped vector v is: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> (&amp;v) Map&lt;RowVectorXi&gt;(data+<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now v is: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The mapped vector v is: 1 2 3 4</span><br><span class="line">Now v is: 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>用这种方法可以在不知道映射数组在内存中位置的情况下构造一个Map对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;Matrix3f&gt; <span class="title">A</span><span class="params">(<span class="literal">NULL</span>)</span></span>;  <span class="comment">// don&#x27;t try to use this matrix yet!</span></span><br><span class="line"><span class="function">VectorXf <span class="title">b</span><span class="params">(n_matrices)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_matrices; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;A) Map&lt;Matrix3f&gt;(<span class="built_in">get_matrix_pointer</span>(i));</span><br><span class="line">    <span class="built_in">b</span>(i) = A.<span class="built_in">trace</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/experiment/%E5%A6%82%E4%BD%95%E5%B0%86Labelme%E6%A0%87%E6%B3%A8%E5%9B%BE%E5%83%8F%E8%BD%AC%E4%B8%BACULane%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/experiment/%E5%A6%82%E4%BD%95%E5%B0%86Labelme%E6%A0%87%E6%B3%A8%E5%9B%BE%E5%83%8F%E8%BD%AC%E4%B8%BACULane%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">如何将Labelme标注图像转为CULane数据集格式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 20:31:34" itemprop="dateCreated datePublished" datetime="2021-04-22T20:31:34+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 14:49:55" itemprop="dateModified" datetime="2021-04-23T14:49:55+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/experiment/" itemprop="url" rel="index"><span itemprop="name">experiment</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>毕设做铁路轨道检测，发现Lane Detection的大部分开源代码都是跑的公用数据集CULane（或Tusimple），而我们自己采集的数据用labelme标注完以后不是CULane的标准格式。为了能直接用公开代码训练我们自己的数据集，需要先把labelme标注的json数据转化成CULane标准格式。</p>
<p>项目地址：[labelme_to_culane] </p>
<h3 id="CULane数据集"><a href="#CULane数据集" class="headerlink" title="CULane数据集"></a>CULane数据集</h3><p>根据<a target="_blank" rel="noopener" href="https://xingangpan.github.io/projects/CULane.html">官网</a>的介绍，CULane数据集文件包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- driver_23_30frame</span><br><span class="line">- driver_161_90frame</span><br><span class="line">- driver_182_30frame</span><br><span class="line">- driver_37_30frame</span><br><span class="line">- driver_100_30frame</span><br><span class="line">- driver_193_90frame</span><br><span class="line">- laneseg_label_w16</span><br><span class="line">- list</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三个训练集&amp;验证集ground truth图像与标注：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- driver_23_30frame</span><br><span class="line">- driver_161_90frame</span><br><span class="line">- driver_182_30frame</span><br></pre></td></tr></table></figure>
<p>每个文件夹下都包含若干视频中抽帧形成的子文件夹，每个子文件夹又包含若干图像数据文件（eg. xxxx.jpg）和一个对应的标注文件（xxxx.lines.txt），以182_30文件为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- driver_182_30frame</span><br><span class="line">  - 05312327_0001.MP4</span><br><span class="line">    |- 00000.jpg</span><br><span class="line">    |- 00000.lines.txt</span><br><span class="line">    |- 00030.jpg</span><br><span class="line">    |- 00030.lines.txt</span><br><span class="line">    |- 00060.jpg</span><br><span class="line">    |- 00060.lines.txt</span><br><span class="line">    ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>标注文件中每一行都给出了车道线上关键点的对应（x，y）坐标，以 <code>05130.lines.txt</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">104.092 590 123.101 580 144.826 570 165.645 560 187.369 550 208.189 540 229.913 530 250.733 520 272.457 510 293.277 500 315.001 490 335.82 480 357.545 470 379.269 460 399.746 450 421.471 440 442.29 430 464.015 420 485.373 410 506.192 400 527.551 390 549.275 380 570.095 370 591.452 360 613.176 350 633.996 340 655.72 330 677.001 320 698.726 310 719.545 300 740.828 290 762.552 280 783.371 270 </span><br><span class="line">661.843 590 665.482 580 669.121 570 673.124 560 677.128 550 681.131 540 684.77 530 688.773 520 692.775 510 696.778 500 700.417 490 704.419 480 708.422 470 712.06 460 716.093 450 720.096 440 724.099 430 727.918 420 731.922 410 735.562 400 739.746 390 743.385 380 747.387 370 751.206 360 755.208 350 759.211 340 763.215 330 766.854 320 770.858 310 774.862 300 778.5 290 782.503 280 786.505 270 </span><br><span class="line">1457.13 590 1438.25 580 1418.46 570 1397.78 560 1377.09 550 1356.41 540 1335.96 530 1315.27 520 1294.59 510 1273.91 500 1253.22 490 1232.77 480 1212.09 470 1192.3 460 1171.62 450 1150.94 440 1130.47 430 1109.79 420 1089.11 410 1068.42 400 1047.74 390 1027.84 380 1007.16 370 986.473 360 965.79 350 945.106 340 924.422 330 903.617 320 883.833 310 863.149 300 842.466 290 821.782 280 801.099 270 </span><br><span class="line">1676.79 450 1632.17 440 1587.27 430 1542.37 420 1497.07 410 1452.17 400 1406.89 390 1361.98 380 1317.08 370 1272.76 360 1227.86 350 1182.96 340 1137.76 330 1092.86 320 1047.96 310 1003.06 300 957.841 290 912.94 280 868.04 270 </span><br></pre></td></tr></table></figure>
<p>其中，关键点选取的y坐标，是固定的，称其为<strong>行锚点</strong> ，默认图像大小为288 * 800：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">culane_row_anchor = [121, 131, 141, 150, 160, 170, 180, 189, 199, 209, 219, 228, 238, 248, 258, 267, 277, 287]</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试集ground truth图像及标注：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- driver_37_30frame</span><br><span class="line">- driver_100_30frame</span><br><span class="line">- driver_193_90frame</span><br></pre></td></tr></table></figure>
<p>格式与训练集/验证集相同</p>
</li>
<li><p>训练集/验证集车道线分割label图像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- laneseg_label_w16</span><br></pre></td></tr></table></figure>
<p>该文件夹下为训练集/验证集中所有ground truth图像所对应的逐像素label图，即每个像素点的值表示它所在的车道线id，0表示背景。</p>
</li>
<li><p>训练集/验证集/测试集列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- </span><br><span class="line">  - list</span><br><span class="line">    |- test_split</span><br><span class="line">       |- test0_normal.txt</span><br><span class="line">       |- test1_crowd.txt</span><br><span class="line">       |- test2_hlight.txt</span><br><span class="line">       |- test3_shadow.txt</span><br><span class="line">       |- test4_noline.txt</span><br><span class="line">       |- test5_arrow.txt</span><br><span class="line">       |- test6_curve.txt</span><br><span class="line">       |- test7_cross.txt</span><br><span class="line">       |- test8_night.txt</span><br><span class="line">    |- test.txt</span><br><span class="line">    |- train.txt</span><br><span class="line">    |- train_gt.txt</span><br><span class="line">    |- val.txt</span><br><span class="line">    |- val_gt.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>trian.txt</code> <code>val.txt</code> <code>test.txt</code> 都是对应训练集/验证集/测试集图像的相对路径，以 <code>test.txt</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/driver_100_30frame/05251517_0433.MP4/00000.jpg</span><br><span class="line">/driver_100_30frame/05251517_0433.MP4/00030.jpg</span><br><span class="line">/driver_100_30frame/05251517_0433.MP4/00060.jpg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>test_split</code> 文件夹下的文件是将测试集 <code>test.txt</code> 分为不同的环境后重组，本质也是图像的相对路径</p>
</li>
<li><p><code>train_gt.txt</code> 和 <code>val_gt.txt</code> 中每行的格式为：</p>
<p>gt图像相对路径 逐像素label图像相对路径 四个0/1数字表示\&lt;左2>&lt;左1>&lt;右1>&lt;右2>四个车道是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/driver_23_30frame/05171102_0766.MP4/00020.jpg /laneseg_label_w16/driver_23_30frame/05171102_0766.MP4/00020.png 1 1 1 0</span><br><span class="line">/driver_23_30frame/05171102_0766.MP4/00050.jpg /laneseg_label_w16/driver_23_30frame/05171102_0766.MP4/00050.png 1 1 1 0</span><br><span class="line">/driver_23_30frame/05171102_0766.MP4/00080.jpg /laneseg_label_w16/driver_23_30frame/05171102_0766.MP4/00080.png 1 1 1 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="从json标注文件到label-png"><a href="#从json标注文件到label-png" class="headerlink" title="从json标注文件到label.png"></a>从json标注文件到label.png</h3><p>labelme提供了将json文件转为label.png的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelme_json_to_dataset [-h] [-o output_file] json_file.json</span><br></pre></td></tr></table></figure>
<p>此方法实现对一个json文件的转换，将生成以下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- output_file</span><br><span class="line">  |- json_file_json</span><br><span class="line">     |- img.png</span><br><span class="line">     |- label.png</span><br><span class="line">     |- label_names.txt</span><br><span class="line">     |- lable_viz.png</span><br></pre></td></tr></table></figure>
<p>实现json文件批量转化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(json_files_path):</span><br><span class="line">    json_data = osp.join(json_files_path, name)</span><br><span class="line">    os.system(<span class="string">&quot;labelme_json_to_dataset json_data -o &quot;</span> + output_path)</span><br></pre></td></tr></table></figure>
<p>如果在标注的时候不是用的纯数字，labelme在进行转换的时候会首先对标注进行字符串排序，排序后的结果在 <code>label_names.txt</code> 中；<code>label.png</code> 虽然看上去是彩色图，但用 <code>PIL.Image</code> 读入后会发现，这其实是个逐像素分类的图，像素值由 <code>label_names.txt</code> 中的标注顺序生成（下标/像素从0开始，其中0表示的是背景，即 <code>label_names.txt</code> 中的第一个默认分类 <code>_background_</code> ）。存在的像素值对应 <code>*_gt.txt</code> 中的值为1，否则为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">label = Image.<span class="built_in">open</span>(label_path)</span><br><span class="line">label_data = ny.asarray(label).copy()</span><br><span class="line">label.save(target_path)</span><br></pre></td></tr></table></figure>
<p>这样就得到了我们需要的 <code>xxxx_label.png</code> 文件</p>
<h3 id="从label-png到-xxxx-lines-txt-和-gt-txt-文件"><a href="#从label-png到-xxxx-lines-txt-和-gt-txt-文件" class="headerlink" title="从label.png到 xxxx.lines.txt 和 *_gt.txt 文件"></a>从label.png到 xxxx.lines.txt 和 *_gt.txt 文件</h3><ul>
<li>根据 <code>label.png</code> 和 <code>culane_row_anchor</code> 获取轨道线上关键点的坐标生成 <code>xxxx.lines.txt</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image = Image.open(image_path)</span></span><br><span class="line">label = Image.<span class="built_in">open</span>(label_path)</span><br><span class="line">w, h = label.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将行采样点按输入图像高度放缩</span></span><br><span class="line"><span class="keyword">if</span> h != <span class="number">288</span>:</span><br><span class="line">    scale_f = <span class="keyword">lambda</span> x : <span class="built_in">int</span>((x * <span class="number">1.0</span>/<span class="number">288</span>) * h)</span><br><span class="line">    sample_tmp = <span class="built_in">list</span>(<span class="built_in">map</span>(scale_f,culane_row_anchor)) </span><br><span class="line">    <span class="comment"># 根据提供的函数对指定序列做映射</span></span><br><span class="line"></span><br><span class="line">lines = <span class="string">&quot;&quot;</span> </span><br><span class="line"><span class="keyword">for</span> i,r <span class="keyword">in</span> <span class="built_in">enumerate</span>(sample_tmp):</span><br><span class="line">    label_r = np.asarray(label)[<span class="built_in">int</span>(<span class="built_in">round</span>(r))] </span><br><span class="line">    <span class="comment"># 取出label图像中行坐标为int(round(r))的一行        </span></span><br><span class="line">    <span class="keyword">for</span> lane_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        line = <span class="string">&quot;&quot;</span></span><br><span class="line">        pos = np.where(label_r == lane_idx)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pos) == <span class="number">0</span>:            </span><br><span class="line">            <span class="keyword">continue</span>        </span><br><span class="line">        pos = np.mean(pos)        </span><br><span class="line">        line = line + <span class="built_in">str</span>(pos) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(r) + <span class="string">&quot; &quot;</span></span><br><span class="line">        <span class="comment"># print(line)</span></span><br><span class="line">        <span class="comment"># cv2.circle(image, (int(round(pos)), int(round(r))), 1, (0,0,255),2)       </span></span><br><span class="line">    lines = lines + line + <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(lines_file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(lines)</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 <code>label.png</code> 生成 <code>*_gt.txt</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lines = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> label_path <span class="keyword">in</span> os.listdir(label_file_path):</span><br><span class="line">    label = Image.<span class="built_in">open</span>(label_path)</span><br><span class="line">    label_data = np.asarray(label).copy()</span><br><span class="line">    np.unique(label_data)</span><br><span class="line">    line = gt_image_path + <span class="string">&#x27; &#x27;</span> + label_path</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> label_data:</span><br><span class="line">            line = line + <span class="string">&#x27; 1&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            line = line + <span class="string">&#x27; 0&#x27;</span></span><br><span class="line">    lines = lines + line + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(gt_file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(lines)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E5%BD%92%E7%BA%A6%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E5%BD%92%E7%BA%A6%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">归约、迭代器和广播机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 11:51:55" itemprop="dateCreated datePublished" datetime="2021-04-22T11:51:55+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:38:02" itemprop="dateModified" datetime="2021-04-23T15:38:02+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍Eigen中的归约( <code>Reductions</code> )，迭代器( <code>Visitors</code> ) 和广播( <code>Broadcasting</code> )机制，以及它们是如何应用与矩阵和数组的。</p>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约指的是一类以矩阵或数组作为输入，返回一个标量值的函数。</p>
<h4 id="常用归约函数"><a href="#常用归约函数" class="headerlink" title="常用归约函数"></a>常用归约函数</h4><p><code>.sum()</code> <code>.prod()</code> <code>.mean()</code> <code>.minCoeff()</code> <code>.maxCoeff()</code> <code>.trace()</code></p>
<h4 id="范数计算"><a href="#范数计算" class="headerlink" title="范数计算"></a>范数计算</h4><ul>
<li><code>.norm()</code> : L-2 范数（所有系数平方和开根号）</li>
<li><code>.squaredNorm()</code> : L-2 范数的平方（所有系数平方和）</li>
<li><code>.lpNorm&lt;p&gt;()</code> : P范数（所有系数绝对值的p次幂之和的p次根），当 <code>p=Infinity</code> 时表示所有系数绝对值的最大值</li>
</ul>
<h4 id="逻辑归约函数"><a href="#逻辑归约函数" class="headerlink" title="逻辑归约函数"></a>逻辑归约函数</h4><ul>
<li><code>.all()</code> : Matrix 或 Array 的所有系数均为 true 时返回 true</li>
<li><code>.any()</code> : Matrix 或 Array 存在某个系数为 true 时返回 true</li>
<li><code>.count()</code> : 返回 Matrix 或 Array 中为 true 的系数总个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ArrayXXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>; </span><br><span class="line">  	a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>,<span class="number">4</span>; </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 0).all()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 0).any()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">any</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 0).count() = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 2).all()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 2).any()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">any</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 2).count() = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a &gt; 0).all()   = 1</span><br><span class="line">(a &gt; 0).any()   = 1</span><br><span class="line">(a &gt; 0).count() = 4</span><br><span class="line"></span><br><span class="line">(a &gt; 2).all()   = 0</span><br><span class="line">(a &gt; 2).any()   = 1</span><br><span class="line">(a &gt; 2).count() = 2</span><br></pre></td></tr></table></figure>
<h4 id="部分归约"><a href="#部分归约" class="headerlink" title="部分归约"></a>部分归约</h4><p>部分归约是可以对矩阵或数组按列或行进行操作的归约，对每个列或行应用归约运算，然后返回具有相应值的列或行向量。部分归约由函数 <code>.colwise()</code> 和 <code>rowwise()</code> 实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Column&#x27;s maximum: &quot;</span> &lt;&lt; endl</span><br><span class="line">   		 &lt;&lt; mat.<span class="built_in">colwise</span>().<span class="built_in">maxCoeff</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Row&#x27;s maximum: &quot;</span> &lt;&lt; endl</span><br><span class="line">   		 &lt;&lt; mat.<span class="built_in">rowwise</span>().<span class="built_in">maxCoeff</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Column<span class="string">&#x27;s maximum: </span></span><br><span class="line"><span class="string">3 2 7 9</span></span><br><span class="line"><span class="string">Row&#x27;</span>s maximum: </span><br><span class="line">9</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>显然：<strong>列操作返回行向量，行操作返回列向量</strong> </p>
<h4 id="将部分归约与其他操作结合"><a href="#将部分归约与其他操作结合" class="headerlink" title="将部分归约与其他操作结合"></a>将部分归约与其他操作结合</h4><p>例：寻找系数和最大的列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  	MatrixXf::Index   maxIndex;</span><br><span class="line">  	<span class="keyword">float</span> maxNorm = mat.<span class="built_in">colwise</span>().<span class="built_in">sum</span>().<span class="built_in">maxCoeff</span>(&amp;maxIndex);</span><br><span class="line">  </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Maximum sum at position &quot;</span> &lt;&lt; maxIndex &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;The corresponding vector is: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; mat.<span class="built_in">col</span>( maxIndex ) &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;And its sum is is: &quot;</span> &lt;&lt; maxNorm &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Maximum sum at position 2</span><br><span class="line">The corresponding vector is: </span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">And its sum is is: 13</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>最常用的就是利用visitor机制获取矩阵/数组中最大值/最小值的位置，交给一个visitor的参数是指向存储行列位置变量的指针，变量类型为 <code>Index</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  	m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  	<span class="comment">//get location of maximum</span></span><br><span class="line">  	MatrixXf::Index maxRow, maxCol;</span><br><span class="line">  	<span class="keyword">float</span> max = m.<span class="built_in">maxCoeff</span>(&amp;maxRow, &amp;maxCol);</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">//get location of minimum</span></span><br><span class="line">  	MatrixXf::Index minRow, minCol;</span><br><span class="line">  	<span class="keyword">float</span> min = m.<span class="built_in">minCoeff</span>(&amp;minRow, &amp;minCol);</span><br><span class="line"> </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Max: &quot;</span> &lt;&lt; max &lt;&lt;  <span class="string">&quot;, at: &quot;</span> </span><br><span class="line">         &lt;&lt; maxRow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; maxCol &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Min: &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;, at: &quot;</span> </span><br><span class="line">         &lt;&lt; minRow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; minCol &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max: 4, at: 1,1</span><br><span class="line">Min: 1, at: 0,0</span><br></pre></td></tr></table></figure>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播机制类似于部分规约，区别在于广播构造了一个表达式，其中向量被解释成了一个矩阵，这个矩阵由向量在行/列方向上复制自身形成。</p>
<h4 id="加减（-、-、-、-）"><a href="#加减（-、-、-、-）" class="headerlink" title="加减（+、-、+=、-=）"></a>加减（+、-、+=、-=）</h4><p><strong>只能用于Vector类型的对象！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	<span class="function">Eigen::VectorXf <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  	mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;   </span><br><span class="line">  	v &lt;&lt; <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">  	<span class="comment">//add v to each column of m</span></span><br><span class="line">  	mat.<span class="built_in">colwise</span>() += v;</span><br><span class="line">  </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Broadcasting result: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Eigen::VectorXf <span class="title">w</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    w &lt;&lt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">       </span><br><span class="line">  	<span class="comment">//add w to each row of m</span></span><br><span class="line">  	mat.<span class="built_in">rowwise</span>() += v.<span class="built_in">transpose</span>();</span><br><span class="line">	  </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Broadcasting result: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Broadcasting result: </span><br><span class="line">1 2 6 9</span><br><span class="line">4 2 8 3</span><br><span class="line">Broadcasting result: </span><br><span class="line">1 3  8 12</span><br><span class="line">4 3 10  6</span><br></pre></td></tr></table></figure>
<p>在执行 <code>mat.colwise() += v</code> 时，相当于进行了两步操作，首先将向量 <code>v</code> 在行方向上复制了4次形成了一个新的4x2的矩阵，再将这个矩阵和矩阵 <code>mat</code> 进行加法操作：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 2 & 6 & 9 \\
3 & 1 & 7 & 2 
\end{bmatrix} + 
\begin{bmatrix}
0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 
\end{bmatrix} = 
\begin{bmatrix}
1 & 2 & 6 & 9 \\
4 & 2 & 8 & 3 
\end{bmatrix}</script><p>只有向量才能进行按行列加减，不能是矩阵，否则会报编译错误；</p>
<p>Array类同理，只能对 <code>ArrayXf</code> 执行这种操作</p>
<h4 id="乘除（、-、-、-）"><a href="#乘除（、-、-、-）" class="headerlink" title="乘除（、/、\=、/=）"></a>乘除（<em>、/、\</em>=、/=）</h4><p>按行/按列执行系数级乘法除法运算。</p>
<p><strong>只能用于 Array 类型的对象！！！</strong></p>
<p>如果想让矩阵第 <code>i</code> 列乘上向量的第 <code>i</code> 个系数，应该写成 <code>mat = mat * v.asDiagonal()</code> </p>
<h4 id="将广播与其他操作结合"><a href="#将广播与其他操作结合" class="headerlink" title="将广播与其他操作结合"></a>将广播与其他操作结合</h4><p>例：在矩阵 <code>m</code> 中找到与向量 <code>v</code> 距离最近的列向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	<span class="function">Eigen::VectorXf <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line"> 	 m &lt;&lt; <span class="number">1</span>, <span class="number">23</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">          <span class="number">3</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">       </span><br><span class="line">  	v &lt;&lt; <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">  	MatrixXf::Index index;</span><br><span class="line">  	<span class="comment">// find nearest neighbour</span></span><br><span class="line">  	(m.<span class="built_in">colwise</span>() - v).<span class="built_in">colwise</span>().<span class="built_in">squaredNorm</span>().<span class="built_in">minCoeff</span>(&amp;index);</span><br><span class="line"> </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Nearest neighbour is column &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; m.<span class="built_in">col</span>(index) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nearest neighbour is column 0:</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E9%AB%98%E7%BA%A7%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E9%AB%98%E7%BA%A7%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">高级初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 11:03:50" itemprop="dateCreated datePublished" datetime="2021-04-22T11:03:50+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:37:24" itemprop="dateModified" datetime="2021-04-23T15:37:24+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍矩阵初始化的一些高级方法，包括逗号初始化和一些特殊矩阵（单位矩阵、零矩阵）初始化</p>
<h3 id="逗号初始化"><a href="#逗号初始化" class="headerlink" title="逗号初始化"></a>逗号初始化</h3><ul>
<li><p>系数初始化顺序：从左上角开始，按从左到右，从上到下的顺序排列</p>
</li>
<li><p>必须预先规定好矩阵/向量/数组的大小，否则会报错</p>
</li>
<li><p>初始化列表的元素除了数值外，也可以是向量或矩阵，常用来连接几个向量或矩阵，同样必须预先规定好大小：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">RowVectorXd <span class="title">vec1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	vec1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;vec1 = &quot;</span> &lt;&lt; vec1 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="function">RowVectorXd <span class="title">vec2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	vec2 &lt;&lt; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;vec2 = &quot;</span> &lt;&lt; vec2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="function">RowVectorXd <span class="title">joined</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">	joined &lt;&lt; vec1, vec2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;joined = &quot;</span> &lt;&lt; joined &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec1 = 1 2 3</span><br><span class="line">vec2 =  1  4  9 16</span><br><span class="line">joined =  1  2  3  1  4  9 16</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用同样的方法按块结构初始化矩阵：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MatrixXf <span class="title">matA</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	matA &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">	<span class="function">MatrixXf <span class="title">matB</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	matB &lt;&lt; matA, matA/<span class="number">10</span>, matA/<span class="number">10</span>, matA;</span><br><span class="line">	cout &lt;&lt; matB &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>   <span class="number">2</span> <span class="number">0.1</span> <span class="number">0.2</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">4</span> <span class="number">0.3</span> <span class="number">0.4</span></span><br><span class="line"><span class="number">0.1</span> <span class="number">0.2</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0.3</span> <span class="number">0.4</span>   <span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>逗号初始化也可以用来为块表达式赋值：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix3f m;</span><br><span class="line">	m.<span class="built_in">row</span>(<span class="number">0</span>) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">	m.<span class="built_in">block</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>;</span><br><span class="line">	m.<span class="built_in">col</span>(<span class="number">2</span>).<span class="built_in">tail</span>(<span class="number">2</span>) &lt;&lt; <span class="number">6</span>, <span class="number">9</span>;                   </span><br><span class="line">	cout &lt;&lt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="特殊矩阵与数组"><a href="#特殊矩阵与数组" class="headerlink" title="特殊矩阵与数组"></a>特殊矩阵与数组</h3><p>参考手册 <a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__QuickRefPage.html#title3">Quick Reference Guide - Predefined Matrices</a> </p>
<h4 id="Zero"><a href="#Zero" class="headerlink" title="Zero()"></a>Zero()</h4><p>初始化所有系数为0，共有三种形式：</p>
<ul>
<li><code>Zero()</code> : 不接收任何变量，仅用于固定大小的对象；</li>
<li><code>Zero(size)</code> : 接收一个变量，仅用于一维动态大小的对象；</li>
<li><code>Zero(rows,cols)</code> : 接收两个变量，仅用于二维动态大小的对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A fixed-size array:\n&quot;</span>;</span><br><span class="line">	Array33f a1 = Array33f::<span class="built_in">Zero</span>();</span><br><span class="line">	cout &lt;&lt; a1 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A one-dimensional dynamic-size array:\n&quot;</span>;</span><br><span class="line">	ArrayXf a2 = ArrayXf::<span class="built_in">Zero</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; a2 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A two-dimensional dynamic-size array:\n&quot;</span>;</span><br><span class="line">	ArrayXXf a3 = ArrayXXf::<span class="built_in">Zero</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; a3 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A fixed-size array:</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line"></span><br><span class="line">A one-dimensional dynamic-size array:</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">A two-dimensional dynamic-size array:</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br></pre></td></tr></table></figure>
<h4 id="Ones"><a href="#Ones" class="headerlink" title="Ones()"></a>Ones()</h4><p>初始化所有系数为1，三种形式与 <code>Zero()</code> 相同</p>
<h4 id="Random"><a href="#Random" class="headerlink" title="Random()"></a>Random()</h4><p>初始化所有系数为随机数，三种形式与 <code>Zero()</code> 相同</p>
<h4 id="Constant-value"><a href="#Constant-value" class="headerlink" title="Constant(value)"></a>Constant(value)</h4><p>初始化所有系数为value，同样三种形式：</p>
<ul>
<li><code>Constant(value)</code></li>
<li><code>Constant(size,value)</code></li>
<li><code>Constant(rows,cols,value)</code> </li>
</ul>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity()"></a>Identity()</h4><p>返回单位矩阵，仅用于 Matrix 类，包括 <code>Identity()</code> 和 <code>Identity(rows,cols)</code> </p>
<h4 id="LinSpaced-size-low-high"><a href="#LinSpaced-size-low-high" class="headerlink" title="LinSpaced(size, low, high)"></a>LinSpaced(size, low, high)</h4><p>仅用于向量或一维数组，返回一个指定大小的向量，其系数在参数 <code>low</code> 和 <code>high</code> 之间等距分布</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ArrayXXf <span class="title">table</span><span class="params">(<span class="number">10</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">0</span>) = ArrayXf::<span class="built_in">LinSpaced</span>(<span class="number">10</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">1</span>) = M_PI / <span class="number">180</span> * table.<span class="built_in">col</span>(<span class="number">0</span>);</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">2</span>) = table.<span class="built_in">col</span>(<span class="number">1</span>).<span class="built_in">sin</span>();</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">3</span>) = table.<span class="built_in">col</span>(<span class="number">1</span>).<span class="built_in">cos</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;  Degrees   Radians      Sine    Cosine\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; table &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Degrees   Radians      Sine    Cosine</span><br><span class="line">      0         0         0         1</span><br><span class="line">     10     0.175     0.174     0.985</span><br><span class="line">     20     0.349     0.342      0.94</span><br><span class="line">     30     0.524       0.5     0.866</span><br><span class="line">     40     0.698     0.643     0.766</span><br><span class="line">     50     0.873     0.766     0.643</span><br><span class="line">     60      1.05     0.866       0.5</span><br><span class="line">     70      1.22      0.94     0.342</span><br><span class="line">     80       1.4     0.985     0.174</span><br><span class="line">     90      1.57         1 -4.37e-08</span><br></pre></td></tr></table></figure>
<p>从这些例子可以看出，上述方法都会返回一个矩阵或数组再赋值给变量（或表达式），方便起见，Eigen还定义了一些函数来方便地执行这些操作，例如 <code>setZero()</code>  <code>MatrixBase::setIdentity()</code>  <code>DenseBase::setLinSpaced()</code> 等。下面这个例程展示了如何使用静态方法、逗号初始化和 <code>setXxx()</code> 函数来初始化矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">mat1</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat1.<span class="built_in">topLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)     = MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">topRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)    = MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">bottomLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)  = MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">bottomRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>) = MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; mat1 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">MatrixXd <span class="title">mat2</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat2.<span class="built_in">topLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setZero</span>();</span><br><span class="line">mat2.<span class="built_in">topRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setIdentity</span>();</span><br><span class="line">mat2.<span class="built_in">bottomLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setIdentity</span>();</span><br><span class="line">mat2.<span class="built_in">bottomRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setZero</span>();</span><br><span class="line">std::cout &lt;&lt; mat2 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">MatrixXd <span class="title">mat3</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat3 &lt;&lt; MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>), MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>),</span><br><span class="line">        MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>), MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; mat3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br></pre></td></tr></table></figure>
<p>除此之外，Eigen还定义了一些用于生成基向量的方法：</p>
<ul>
<li><code>Vector3f::UnitX()</code> : (1, 0, 0)</li>
<li><code>Vector3f::UnitY()</code> : (0, 1, 0)</li>
<li><code>Vector3f::UnitZ()</code> : (0, 0, 1)</li>
<li><code>VectorXf::Unit(size,i)</code> : <ul>
<li>例如 ：<code>VectorXf::Unit(4,1)</code> == <code>Vector4f(0,1,0,0)</code> == <code>Vector4f::UnitY()</code> </li>
</ul>
</li>
</ul>
<h3 id="用作临时对象"><a href="#用作临时对象" class="headerlink" title="用作临时对象"></a>用作临时对象</h3><p>无论是逗号初始化程序还是上面介绍的几种类内静态方法，都可以用作表达式中的临时对象。</p>
<p>逗号初始化程序用作临时对象时，需要调用 <code>finished()</code> 方法获取实际的矩阵对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MatrixXd m = MatrixXd::<span class="built_in">Random</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    m = (m + MatrixXd::<span class="built_in">Constant</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1.2</span>)) * <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m =&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    v &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m * v =&quot;</span> &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;</span><br><span class="line">    MatrixXf mat = MatrixXf::<span class="built_in">Random</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mat =\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">	mat = (<span class="built_in">MatrixXf</span>(<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="built_in">finished</span>() * mat;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mat =\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m =</span><br><span class="line">  10 55.9 14.7</span><br><span class="line">23.2 63.3 77.9</span><br><span class="line">85.6 31.9 77.9</span><br><span class="line">m * v =</span><br><span class="line">166</span><br><span class="line">383</span><br><span class="line">383</span><br><span class="line">mat =</span><br><span class="line">     -1   0.511  0.0655</span><br><span class="line"> -0.737 -0.0827  -0.562</span><br><span class="line">mat =</span><br><span class="line"> -0.737 -0.0827  -0.562</span><br><span class="line">     -1   0.511  0.0655</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E5%9D%97%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E5%9D%97%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">块操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 10:38:08" itemprop="dateCreated datePublished" datetime="2021-04-22T10:38:08+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:38:45" itemprop="dateModified" datetime="2021-04-23T15:38:45+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍 Matrix 和 Array 中的块操作。</p>
<h3 id="块操作-block"><a href="#块操作-block" class="headerlink" title="块操作 .block()"></a>块操作 .block()</h3><p>取一个从 <code>(i,j)</code> 开始的，大小为 <code>(p,q)</code> 的块，有两种语法：</p>
<ul>
<li><code>matrix.block(i,j,p,q);</code> =&gt; 构造一个动态大小的块</li>
<li><code>matrix.block&lt;p,q&gt;(i,j);</code> =&gt; 构造一个固定大小的块</li>
</ul>
<p>两种语法的执行结果相同，都能用在固定大小/动态大小的矩阵/数组上。唯一不同的是当块大小已知且比较小的时候，返回固定大小的块能让代码执行得更快一点。</p>
<p>尽管 <code>.block()</code> 方法可以用于任何块操作，但对于特殊情况，使用更具针对性的方法能提供更好的性能，下面将介绍三种特殊方法。</p>
<h3 id="行列操作"><a href="#行列操作" class="headerlink" title="行列操作"></a>行列操作</h3><ul>
<li>取第 <code>i</code> 行：<code>matrix.row(i)</code> </li>
<li>取第 <code>j</code> 列：<code>matrix.col(j)</code> </li>
</ul>
<h3 id="与角相关的操作"><a href="#与角相关的操作" class="headerlink" title="与角相关的操作"></a>与角相关的操作</h3><p>同样也有返回动态大小/固定大小两种语法</p>
<ul>
<li>左上角 <code>p*q</code> ：<code>matrix.topLeftCorner(p,q);</code>     <code>matrix.topLeftCorner&lt;p,q&gt;();</code> </li>
<li>左下角 <code>p*q</code> ：<code>matrix.bottomLeftCorner(p,q);</code>     <code>matrix.bottomLeftCorner&lt;p,q&gt;();</code></li>
<li>右上角 <code>p*q</code> ：<code>matrix.topRightCorner(p,q);</code>     <code>matrix.topRightCorner&lt;p,q&gt;();</code> </li>
<li>右下角 <code>p*q</code> ：<code>matrix.bottomRightCorner(p,q);</code>     <code>matrix.bottomRightCorner&lt;p,q&gt;();</code>  </li>
<li>取前 <code>q</code> 行：<code>matrix.topRows(q);</code>     <code>matrix.topRows&lt;q&gt;();</code> </li>
<li>取后 <code>q</code> 行：<code>matrix.bottomRows(q);</code>     <code>matrix.bottomRows&lt;q&gt;();</code> </li>
<li>取前 <code>p</code> 列：<code>matrix.leftCols(p);</code>     <code>matrix.leftCols&lt;p&gt;();</code> </li>
<li>取后 <code>p</code> 列：<code>matrix.rightCols(q);</code>     <code>matrix.rightCols&lt;q&gt;();</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Eigen::Matrix4f m;</span><br><span class="line">    m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">         <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">         <span class="number">9</span>, <span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">         <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m.leftCols(2) =&quot;</span> &lt;&lt; endl </span><br><span class="line">         &lt;&lt; m.<span class="built_in">leftCols</span>(<span class="number">2</span>) &lt;&lt; endl </span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m.bottomRows&lt;2&gt;() =&quot;</span> &lt;&lt; endl </span><br><span class="line">         &lt;&lt; m.bottomRows&lt;<span class="number">2</span>&gt;() &lt;&lt; endl </span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">topLeftCorner</span>(<span class="number">1</span>,<span class="number">3</span>) = m.<span class="built_in">bottomRightCorner</span>(<span class="number">3</span>,<span class="number">1</span>).<span class="built_in">transpose</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After assignment, m = &quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m.leftCols(2) =</span><br><span class="line"> 1  2</span><br><span class="line"> 5  6</span><br><span class="line"> 9 10</span><br><span class="line">13 14</span><br><span class="line"></span><br><span class="line">m.bottomRows&lt;2&gt;() =</span><br><span class="line"> 9 10 11 12</span><br><span class="line">13 14 15 16</span><br><span class="line"></span><br><span class="line">After assignment, m = </span><br><span class="line"> 8 12 16  4</span><br><span class="line"> 5  6  7  8</span><br><span class="line"> 9 10 11 12</span><br><span class="line">13 14 15 16</span><br></pre></td></tr></table></figure>
<h3 id="对向量和一维数组的块操作"><a href="#对向量和一维数组的块操作" class="headerlink" title="对向量和一维数组的块操作"></a>对向量和一维数组的块操作</h3><p>同样也有返回动态大小/固定大小两种语法</p>
<ul>
<li>包含前 <code>n</code> 个元素：<code>vector.head(n);</code>     <code>vector.head&lt;n&gt;();</code> </li>
<li>包含后 <code>n</code> 个元素：<code>vector.tail(n);</code>     <code>vector.tail&lt;n&gt;();</code> </li>
<li>从 <code>i</code> 开始，包含 <code>n</code> 个元素：<code>vector.segment(i,n);</code>     <code>vector.segment&lt;n&gt;(i);</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Eigen::ArrayXf <span class="title">v</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    v &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.head(3) =&quot;</span> &lt;&lt; endl &lt;&lt; v.<span class="built_in">head</span>(<span class="number">3</span>) &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v.tail&lt;3&gt;() = &quot;</span> &lt;&lt; endl &lt;&lt; v.tail&lt;<span class="number">3</span>&gt;() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">segment</span>(<span class="number">1</span>,<span class="number">4</span>) *= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after &#x27;v.segment(1,4) *= 2&#x27;, v =&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">v.head(3) =</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">v.tail&lt;3&gt;() = </span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">after <span class="string">&#x27;v.segment(1,4) *= 2&#x27;</span>, v =</span><br><span class="line"> 1</span><br><span class="line"> 4</span><br><span class="line"> 6</span><br><span class="line"> 8</span><br><span class="line">10</span><br><span class="line"> 6</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/Array%E7%B1%BB%E4%B8%8E%E7%B3%BB%E6%95%B0%E7%BA%A7%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/Array%E7%B1%BB%E4%B8%8E%E7%B3%BB%E6%95%B0%E7%BA%A7%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Array类与系数级操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 09:59:39" itemprop="dateCreated datePublished" datetime="2021-04-22T09:59:39+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:40:17" itemprop="dateModified" datetime="2021-04-23T15:40:17+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍Eigen中的Array类。</p>
<p>Matrix类主要面向线性代数，Array类则提供更普遍意义上的数组操作，允许进行没有具体线代意义的系数级运算，例如给每个系数加上一个常数，或将两个数组按系数相乘等。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Array的六个模板参数和Matrix一模一样，并且也定义了一些常用类型</p>
<ul>
<li><code>ArrayNt</code> ：表示一个一维数组，<code>N</code> 为数组大小，<code>t</code> 为数值类型</li>
<li><code>ArrayNNt</code> ：表示一个二维数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Array&lt;<span class="keyword">float</span>, Dynamic, <span class="number">1</span>&gt; ArrayXf;</span><br><span class="line"><span class="keyword">typedef</span> Array&lt;<span class="keyword">float</span>, <span class="number">3</span>, <span class="number">1</span>&gt; Array3f;</span><br><span class="line"><span class="keyword">typedef</span> Array&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; ArrayXXd;</span><br><span class="line"><span class="keyword">typedef</span> Array&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; Array33d;</span><br></pre></td></tr></table></figure>
<h3 id="访问系数"><a href="#访问系数" class="headerlink" title="访问系数"></a>访问系数</h3><p>与Matrix相同，Array也是通过重载括号运算符 <code>()</code> 实现对数组系数的读写操作；重载 <code>&lt;&lt;</code> 操作符逗号初始化数组或打印数组。</p>
<h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><p>与Matrix相同，当两个数组大小相同时操作有效，且加减法按系数进行；</p>
<p>与Matrix不同，Array也支持 <code>array+scalar</code> 的操作，即向Array中的每个系数加上同一个常数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ArrayXXf <span class="title">a</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">ArrayXXf <span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">       <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">  b &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">       </span><br><span class="line">  <span class="comment">// Adding two arrays</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; endl &lt;&lt; a + b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Subtracting a scalar from an array</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a - 2 = &quot;</span> &lt;&lt; endl &lt;&lt; a - <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a + b = </span><br><span class="line"> 2  4  6</span><br><span class="line"> 5  7  9</span><br><span class="line"> 8 10 12</span><br><span class="line"></span><br><span class="line">a - 2 = </span><br><span class="line">-1  0  1</span><br><span class="line"> 2  3  4</span><br><span class="line"> 5  6  7</span><br></pre></td></tr></table></figure>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ul>
<li><code>array * scalar</code> 或 <code>scalar * array</code> ：同Matrix</li>
<li><code>array * array</code> ：与Matrix不同。Matrix进行的是矩阵乘法，Array则是系数对应相乘。因此当且仅当两个数组维度相同时，才能相乘。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ArrayXXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">ArrayXXf <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">  b &lt;&lt; <span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">       <span class="number">7</span>,<span class="number">8</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; endl &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a * b = </span><br><span class="line"> <span class="number">5</span> <span class="number">12</span></span><br><span class="line"><span class="number">21</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="其他系数级操作"><a href="#其他系数级操作" class="headerlink" title="其他系数级操作"></a>其他系数级操作</h3><p>参考Eigen手册 <a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__QuickRefPage.html#title6">Quick Reference Guide : Coefficient-wise &amp; Array operators</a>  </p>
<h3 id="Array-与-Matrix-类型转换"><a href="#Array-与-Matrix-类型转换" class="headerlink" title="Array 与 Matrix 类型转换"></a>Array 与 Matrix 类型转换</h3><ul>
<li>Array -&gt; Matrix : <code>A.matrix()</code> </li>
<li>Matrix -&gt; Array : <code>M.array()</code> </li>
</ul>
<p>Eigen禁止在一个表达式中混用Array和Matrix，唯一例外的是 <code>赋值运算</code> ，它允许Array和Matrix的互相赋值。</p>
<p>Eigen也为Matrix提供了一些 <code>cwise*()</code> 的方法使其允许直接进行系数级操作，类似 <code>.array().*()</code> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">向量矩阵运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 12:57:57" itemprop="dateCreated datePublished" datetime="2021-04-21T12:57:57+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:40:54" itemprop="dateModified" datetime="2021-04-23T15:40:54+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这章介绍Eigen中矩阵、向量和标量之间的运算。对Matrix类，运算符重载仅支持线性代数运算，例如矩阵x矩阵，而像向量+标量的操作是不允许的。Array类则允许执行所有的数组操作，见 <strong>The Array Class and Coefficient-wise Operations</strong> 。</p>
<h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><p>Eigen不会自动执行类型转换，所以左右维度和数值类型必须保证相同。可用的操作符包括：</p>
<ul>
<li>一元操作符 <code>-</code> : -a</li>
<li>二元操作符 <code>+</code> <code>-</code> : a+b, a-b</li>
<li>复合操作符 <code>+=</code> <code>-=</code> : a+=b, a-=b</li>
</ul>
<h3 id="标量乘除"><a href="#标量乘除" class="headerlink" title="标量乘除"></a>标量乘除</h3><p>矩阵所有系数乘/除以该标量。可用操作符包括：</p>
<ul>
<li>二元操作符 <code>*</code> : matrix <em> scalar, scalar </em> matrix</li>
<li>二元操作符 <code>/</code> : matrix / scalar</li>
<li>复合操作符 <code>*=</code> <code>/=</code> : matrix *= scalar, matrix /= scalar</li>
</ul>
<h3 id="转置与共轭"><a href="#转置与共轭" class="headerlink" title="转置与共轭"></a>转置与共轭</h3><ul>
<li><code>transpose()</code> : $\boldsymbol{a}^T$ （转置）</li>
<li><code>conjugate()</code>  : $\overline{\boldsymbol{a}}$  （共轭）</li>
<li><code>adjoint()</code> : $\boldsymbol{a}^*$     （共轭转置）</li>
</ul>
<p>显然，对实矩阵而言，<code>conjugate()</code> 并不执行什么操作，所以 <code>adjoint()</code> 完全等同于 <code>transpose()</code> 。</p>
<p>需要<strong>非常注意</strong>的一点是，基本运算符 <code>transpose()</code> 和 <code>adjoint()</code> 仅仅返回一个代理对象，而并未进行实质的运算。例如，执行 <code>b = a.transpose()</code> 时，Eigen在将结果写入b的同时执行转置；从而引出另一个问题，如果执行 <code>a = a.transpose()</code> ，Eigen同样会在转置完成前开始将结果写入矩阵a，因此这句话不会像预期一样将a变为它的转置，反而会在执行过程中得到 <code>aliasing issue</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix3i a;</span><br><span class="line">    Eigen::Matrix3i b;</span><br><span class="line">    a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;origin matrix a:\n&quot;</span></span><br><span class="line">         &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = a.<span class="built_in">transpose</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b as the transpose of matrix a:\n&quot;</span></span><br><span class="line">         &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = a.<span class="built_in">transpose</span>(); <span class="comment">// !!! DO NOT DO THIS !!!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here is the result of the aliasing effect:\n&quot;</span></span><br><span class="line">         &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">origin matrix a:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">b as the transpose of matrix a:</span><br><span class="line">1 4 7</span><br><span class="line">2 5 8</span><br><span class="line">3 6 9</span><br><span class="line">main: /usr/include/eigen3/Eigen/src/Core/Transpose.h:378: static void Eigen::internal::checkTransposeAliasing_impl&lt;Derived, OtherDerived, MightHaveTransposeAliasing&gt;::run(const Derived&amp;, const OtherDerived&amp;) [with Derived = Eigen::Matrix&lt;int, 3, 3&gt;; OtherDerived = Eigen::Transpose&lt;Eigen::Matrix&lt;int, 3, 3&gt; &gt;; bool MightHaveTransposeAliasing = <span class="literal">true</span>]: Assertion `(!check_transpose_aliasing_run_time_selector &lt;typename Derived::Scalar,blas_traits&lt;Derived&gt;::IsTransposed,OtherDerived&gt; ::run(extract_data(dst), other)) &amp;&amp; <span class="string">&quot;aliasing detected during transposition, use transposeInPlace() &quot;</span> <span class="string">&quot;or evaluate the rhs into a temporary using .eval()&quot;</span><span class="string">&#x27; failed.</span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br></pre></td></tr></table></figure>
<p>所谓<strong>混叠问题</strong>，即 <code>aliasing issue</code> ，指的是在赋值表达式的左右两边存在矩阵的重叠区域，这种情况下，有可能得到非预期的结果，具体见 <strong>Aliasing</strong> 。</p>
<p>如果想执行就地转置（in-place transposition），调用 <code>transposeInPlace()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">transposeInPlace</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After being transposed:\n&quot;</span></span><br><span class="line">     &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">After being transposed:</span><br><span class="line">1 4 7</span><br><span class="line">2 5 8</span><br><span class="line">3 6 9</span><br></pre></td></tr></table></figure>
<p>同理，也有为复矩阵准备的就地共轭转置 <code>adjointInPlace()</code> 方法</p>
<h3 id="矩阵-矩阵乘法乘法"><a href="#矩阵-矩阵乘法乘法" class="headerlink" title="矩阵-矩阵乘法乘法"></a>矩阵-矩阵乘法乘法</h3><p>向量是一种特殊的矩阵，因此矩阵-向量、向量-向量乘法也包括其中。可用操作符有：</p>
<ul>
<li>二元操作符 <code>*</code> : a*b</li>
<li>复合操作符 <code>*=</code> : a*=b</li>
</ul>
<p>执行操作 <code>m = m * m</code> 是安全的，因为Eigen将矩阵乘法当作一种特殊形式进行处理，会在编译时引入一个临时变量，所以不必担心会出现 <code>aliasing issue</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp = m * m;</span><br><span class="line">m = tmp;</span><br></pre></td></tr></table></figure>
<p>当然，如果你很清楚自己的矩阵乘法不会有引起 <code>aliasing issue</code> 的可能，也可以调用 <code>noalias()</code> 方法来避免引入临时变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">noalias</span>() += a*b;</span><br></pre></td></tr></table></figure>
<h3 id="向量点乘和叉乘"><a href="#向量点乘和叉乘" class="headerlink" title="向量点乘和叉乘"></a>向量点乘和叉乘</h3><p><code>dot()</code> 和 <code>corss()</code> 方法分别实现向量点乘和叉乘，当然，点乘也可以通过 <code>u.adjoint()*v</code> 实现，只不过返回的结果是个1x1的矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dot product: &quot;</span> &lt;&lt; v.<span class="built_in">dot</span>(w) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">double</span> dp = v.<span class="built_in">adjoint</span>() * w; <span class="comment">// automatic conversion of the inner product to a scalar</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dot product via a matrix product: &quot;</span> &lt;&lt; dp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cross product:\n&quot;</span></span><br><span class="line">         &lt;&lt; v.<span class="built_in">cross</span>(w) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dot product: 8</span><br><span class="line">Dot product via a matrix product: 8</span><br><span class="line">Cross product:</span><br><span class="line"> 1</span><br><span class="line">-2</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<p>需要<strong>非常注意</strong>的是，<font color="#ff0000">叉乘只能用于大小为3的向量 </font>；点乘则可用于任意大小的向量</p>
<h3 id="基本算数归约运算"><a href="#基本算数归约运算" class="headerlink" title="基本算数归约运算"></a>基本算数归约运算</h3><p>Eigen提供了一些归约运算（reduction operation），将给定的矩阵或向量归约为单个值，例如 <code>sum()</code> , <code>prod()</code> , <code>maxCoeff()</code> , <code>minCoeff()</code> , <code>trace()</code> 分别表示所有矩阵系数的和、积、最大值、最小值，以及矩阵的迹，矩阵的迹也可以通过 <code>m.diagonal().sum()</code> 求得。</p>
<p>通过向 <code>maxCoeff()</code> 或 <code>minCoeff()</code> 中传入 <code>std::ptrdiff_t</code> 类型的参数指针，可以得到对应最大值/最小值的坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix3f m = Matrix3f::<span class="built_in">Random</span>();</span><br><span class="line">    std::<span class="keyword">ptrdiff_t</span> i, j;</span><br><span class="line">    <span class="keyword">float</span> minOfM = m.<span class="built_in">minCoeff</span>(&amp;i, &amp;j);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here is the matrix m:\n&quot;</span></span><br><span class="line">         &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Its minimum coefficient (&quot;</span> &lt;&lt; minOfM</span><br><span class="line">         &lt;&lt; <span class="string">&quot;) is at position (&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;)\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    RowVector4i v = RowVector4i::<span class="built_in">Random</span>();</span><br><span class="line">    <span class="keyword">int</span> maxOfV = v.<span class="built_in">maxCoeff</span>(&amp;i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here is the vector v: &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Its maximum coefficient (&quot;</span> &lt;&lt; maxOfV</span><br><span class="line">         &lt;&lt; <span class="string">&quot;) is at position &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix m:</span><br><span class="line"> 0.680375   0.59688 -0.329554</span><br><span class="line">-0.211234  0.823295  0.536459</span><br><span class="line"> 0.566198 -0.604897 -0.444451</span><br><span class="line">Its minimum coefficient (-0.604897) is at position (2,1)</span><br><span class="line"></span><br><span class="line">Here is the vector v:  115899597  -48539462  276748203 -290373134</span><br><span class="line">Its maximum coefficient (276748203) is at position 2</span><br></pre></td></tr></table></figure>
<h3 id="操作有效性"><a href="#操作有效性" class="headerlink" title="操作有效性"></a>操作有效性</h3><p>Eigen会在执行操作的时候检查有效性。</p>
<p>重要的编译错误信息会用大写突出出来。</p>
<p>但更多时候（例如检查动态大小的矩阵的操作），编译过程不会检查出错误。Eigen将在 <code>debug mode</code> 下使用 <code>runtime assertions</code> 让程序在运行过程中碰到非法操作的时候退出，同时报出错误信息。如果关掉assertions，程序很有可能会崩溃。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="潘薇鸿"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">潘薇鸿</p>
  <div class="site-description" itemprop="description">跬步千里</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WeihongPan" title="GitHub → https://github.com/WeihongPan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘薇鸿</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
