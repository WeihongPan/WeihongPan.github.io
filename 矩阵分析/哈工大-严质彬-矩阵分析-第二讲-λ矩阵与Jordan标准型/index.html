<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weihongpan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"mac","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Chapter2 $\lambda$ 矩阵与Jordan标准型为了解决数域矩阵相似最简型的问题，我们引入 $\lambda$ 矩阵 $\lambda$ 矩阵及其Smith型$\lambda$ 矩阵以多项式为元素的矩阵  $\mathbb{F}[\lambda]$ ：表示以数域 $\mathbb{F}$ 中的元素为系数的多项式集合 $(\mathbb{F}[\lambda])^{m\times n}">
<meta property="og:type" content="article">
<meta property="og:title" content="矩阵分析学习笔记2：多项式矩阵与Jordan标准型">
<meta property="og:url" content="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/index.html">
<meta property="og:site_name" content="潘薇鸿">
<meta property="og:description" content="Chapter2 $\lambda$ 矩阵与Jordan标准型为了解决数域矩阵相似最简型的问题，我们引入 $\lambda$ 矩阵 $\lambda$ 矩阵及其Smith型$\lambda$ 矩阵以多项式为元素的矩阵  $\mathbb{F}[\lambda]$ ：表示以数域 $\mathbb{F}$ 中的元素为系数的多项式集合 $(\mathbb{F}[\lambda])^{m\times n}">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-28T05:30:03.000Z">
<meta property="article:modified_time" content="2021-05-29T00:47:15.112Z">
<meta property="article:author" content="潘薇鸿">
<meta property="article:tag" content="矩阵分析">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>矩阵分析学习笔记2：多项式矩阵与Jordan标准型 | 潘薇鸿</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">潘薇鸿</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">keep on fighting</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/WeihongPan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          矩阵分析学习笔记2：多项式矩阵与Jordan标准型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-28 13:30:03" itemprop="dateCreated datePublished" datetime="2021-05-28T13:30:03+08:00">2021-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-29 08:47:15" itemprop="dateModified" datetime="2021-05-29T08:47:15+08:00">2021-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">矩阵分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Chapter2-lambda-矩阵与Jordan标准型"><a href="#Chapter2-lambda-矩阵与Jordan标准型" class="headerlink" title="Chapter2 $\lambda$ 矩阵与Jordan标准型"></a>Chapter2 $\lambda$ 矩阵与Jordan标准型</h3><p>为了解决数域矩阵相似最简型的问题，我们引入 $\lambda$ 矩阵</p>
<h4 id="lambda-矩阵及其Smith型"><a href="#lambda-矩阵及其Smith型" class="headerlink" title="$\lambda$ 矩阵及其Smith型"></a>$\lambda$ 矩阵及其Smith型</h4><h5 id="lambda-矩阵"><a href="#lambda-矩阵" class="headerlink" title="$\lambda$ 矩阵"></a>$\lambda$ 矩阵</h5><p>以多项式为元素的矩阵</p>
<ul>
<li>$\mathbb{F}[\lambda]$ ：表示以数域 $\mathbb{F}$ 中的元素为系数的多项式集合</li>
<li>$(\mathbb{F}[\lambda])^{m\times n}=\{[a_{ij}(\lambda)]_{m\times n}|a_{ij}(\lambda)\in \mathbb{F}[\lambda]\}$ （类比 $\mathbb{F}^{m\times n}$） </li>
<li>$\lambda$ 矩阵： $\boldsymbol{A}(\lambda)=[a_{ij}(\lambda)]_{m\times n},\ a_{ij}(\lambda)\in\mathbb{F}[\lambda],\ \boldsymbol{A}(\lambda)\in(\mathbb{F}[\lambda])^{m\times n}$  </li>
<li>从映射观点看 $\lambda$ 矩阵：$\mathbb{F}\rightarrow\mathbb{F}^{m\times n},\ \lambda\mapsto\boldsymbol{A}(\lambda)$ </li>
<li>从矩阵多项式观点看 $\lambda$ 矩阵：$\boldsymbol{A}(\lambda) = A_0+A_1\lambda+A_2\lambda^2+\cdots+$ ，即以矩阵为系数的多项式</li>
</ul>
<p>$\lambda$ 矩阵的秩</p>
<ul>
<li>不为<strong>零多项式</strong>的子式的最大阶数 （以多项式为元素算行列式）</li>
</ul>
<h5 id="单位模阵（幺模阵）"><a href="#单位模阵（幺模阵）" class="headerlink" title="单位模阵（幺模阵）"></a>单位模阵（幺模阵）</h5><ul>
<li>对 $\boldsymbol{U}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n}$ ，若 $\exists\ \boldsymbol{V}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n},\ s.t.\ \boldsymbol{U}(\lambda)\boldsymbol{V}(\lambda)=\boldsymbol{V}(\lambda)\boldsymbol{U}(\lambda)=\boldsymbol{I}_n$ ，则称 $\boldsymbol{V}(\lambda)$ 为 $\boldsymbol{U}(\lambda)$ 的单位模阵。</li>
</ul>
<p>单位模阵：逆矩阵，且必须是多项式矩阵，因为单纯逆矩阵 $\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^*$ 不一定是多项式矩阵</p>
<p>多项式矩阵相对于前面所谈论的数值矩阵，主要不同就在于除法运算上，即多项式相除结果不一定还是多项式。用抽象数学的概念，数值矩阵谈论是<strong>域</strong>上的矩阵，而多项式矩阵谈论的是<strong>环</strong>上的矩阵</p>
<ul>
<li>$\boldsymbol{U}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n}$ 为单位模阵 $\Leftrightarrow |\boldsymbol{U}(\lambda)|$ 是非零常值多项式（即 $a_0\neq 0$ 的零次多项式）</li>
</ul>
<p>下面给出证明：</p>
<p>$\Leftarrow$ ：显然</p>
<p>$\Rightarrow$ ：存在多项式矩阵 $\boldsymbol{V}(\lambda)$ ，使得 $\boldsymbol{U}(\lambda)\boldsymbol{V}(\lambda)=\boldsymbol{I}_n\Rightarrow|\boldsymbol{U}(\lambda)||\boldsymbol{V}(\lambda)|=1\Rightarrow f(\lambda)g(\lambda)=1$ ，两个多项式相乘等于1，这两个多项式只能是 $a_0\neq 0$ 的零次多项式，否则相乘一定有变量在 </p>
<h5 id="lambda-矩阵的初等行（列）变换"><a href="#lambda-矩阵的初等行（列）变换" class="headerlink" title="$\lambda$ 矩阵的初等行（列）变换"></a>$\lambda$ 矩阵的初等行（列）变换</h5><p>以初等行变换为例 $\Leftrightarrow$ 左乘一个相应的初等矩阵：</p>
<ul>
<li><p>某两行互换 $\Leftrightarrow$ eg. $\begin{bmatrix} 0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
</li>
<li><p><strong>某行乘以非零常数</strong> $\Leftrightarrow$ eg. $\begin{bmatrix} c&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
<p>注：不是乘以非零多项式！因为乘以多项式是不可逆的，即对应乘上的矩阵没有单位模阵</p>
</li>
<li><p>某行乘以一个多项式再加到另一行上 $\Leftrightarrow$ eg. $\begin{bmatrix}1&amp;0&amp;0\\f(\lambda)&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
</li>
</ul>
<h5 id="lambda-矩阵经左右初等变换化简"><a href="#lambda-矩阵经左右初等变换化简" class="headerlink" title="$\lambda$ 矩阵经左右初等变换化简"></a>$\lambda$ 矩阵经左右初等变换化简</h5><ul>
<li><p>$\lambda$ 矩阵的等价：经初等行列变换可以互相转化的两个 $\lambda$ 矩阵等价，记作 $\boldsymbol{A}(\lambda) \sim \boldsymbol{B}(\lambda) $ </p>
</li>
<li><p>【用初等行变换为矩阵左上角降次】设 $\boldsymbol{A}(\lambda) =[a_{ij}(\lambda)]_{m\times n},\ a_{11}(\lambda)\neq0$ ， 且至少有一个元素不能被 $a_{11}(\lambda)$ 整除（$\Leftrightarrow a_{11}(\lambda)$ 不为非零常值多项式 ），则有 $\boldsymbol{A}(\lambda) \sim\boldsymbol{B}(\lambda) $ 且 $b_{11}(\lambda)\neq0,\ \partial(b_{11}(\lambda))&lt;\partial(a_{11}(\lambda))$ （$\partial(多项式)$ 表示该多项式的次数）</p>
<p>下面给出证明概要：</p>
<ul>
<li><p>同行中有一个元素 $a_{1j}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除，即 $a_{1j}(\lambda)=a_{11}(\lambda)q(\lambda)+r(\lambda),\ 且\ \partial(r(\lambda))&lt;\partial(a(\lambda))$ ，所以，将第一列乘以 $-q(\lambda)$ 加到第 $j$ 列后交换第一列与第 $j$ 列，此时 $a_{11}(\lambda)’=r(\lambda),\partial(a_{11}(\lambda)’)&lt;\partial(a_{11}(\lambda))$ ，从而实现降次</p>
</li>
<li><p>同列中有一个元素 $a_{i1}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除，同理</p>
</li>
<li><p>同行同列都能被整除，但有 $a_{ij}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除。</p>
<p>首先可以通过一系列行列变换把第一列、第一行除了 $a_{11}(\lambda)$ 外都化为0，同时保证变换后的 $a_{ij}(\lambda)’$ 仍旧不能被 $a_{11}(\lambda)$ 整除（不能被整除的数加上除数的倍数依然不能被整除），将变换后的第 $j$ 行加到第1行，就回到第一种情况了</p>
</li>
</ul>
</li>
</ul>
<h5 id="Smith-型-lambda-矩阵"><a href="#Smith-型-lambda-矩阵" class="headerlink" title="Smith 型 $\lambda$ 矩阵"></a>Smith 型 $\lambda$ 矩阵</h5><p>设：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}(\lambda)\sim \boldsymbol{B}(\lambda)=
\left[
\begin{array}{ccc|ccc}
    d_1({\lambda}) & & & 0 & \cdots & 0\\
    & \ddots & &\vdots &\ddots &\vdots \\
    & & d_r(\lambda) &0 &\cdots &0 \\
    \hline 
    0 & \cdots & 0 &0 &\cdots &0 \\
    \vdots &\ddots &\vdots &\vdots &\ddots &\vdots \\
    0 & \cdots & 0 &0 &\cdots &0
\end{array}
\right]</script><p>其中 $r=\text{rank}(\boldsymbol{A}(\lambda))$ ，$d_i(\lambda)$ 为非零多项式，且 $d_i(\lambda)|d_{i+1}(\lambda)$ （$f(\lambda)|g(\lambda)$ 表示 $f$ 整除 $g$ ），则称 $\boldsymbol{B}(\lambda)$ 为 $\boldsymbol{A}(\lambda)$ 的 <code>Smith标准型</code> 。</p>
<p>下面给出证明：</p>
<ul>
<li><p>存在性</p>
<p>若为零矩阵，则显然；若为非零矩阵，必存在非零多项式，通过行列变换将次数最低的非零多项式移到 $a_{11}(\lambda)$ ，会出现以下两种情况：</p>
<ul>
<li>矩阵中所有元素都能被 $a_{11}(\lambda)$ 整除</li>
<li>存在若干元素不能被 $a_{11}(\lambda)$ 整除</li>
</ul>
<p>对于第二种情况，【用初等行变换为左上角降次】，降次必然是有限的，不能再降次的时候，也就是矩阵中的所有元素都能被 $a_{11}(\lambda)$ 整除的时候 ，进而同行同列的元素都能化成0</p>
<p>对右下子矩阵进行相同的操作，以此类推，最终得到 <code>Smith标准型</code> </p>
</li>
<li><p>唯一性</p>
<p>约定 $d_i(\lambda)$ 都是首1多项式，即最高次数系数为1</p>
<ul>
<li><p><strong>$\lambda$ 矩阵的 $k$ 阶行列式因子</strong> ：$\boldsymbol{A}(\lambda)$ 的所有 $k$ 阶子式的最高公因式</p>
</li>
<li><p><strong>初等变换不改变 $k$ 阶行列式因子</strong> </p>
<p>下面给出证明：</p>
<p>设 $\mathscr{A}=\{\boldsymbol{A}\ 的\ k\ 阶子式\},\mathscr{B}=\{\boldsymbol{B}\ 的\ k\ 阶子式\}$ ，只需证 $\mathscr{A},\mathscr{B}$ 的最高公因式相同。</p>
<p>任取 $f(\lambda)\in\mathscr{B}$ ，考察它与 $\mathscr{A}$ 中多项式的关系，由于初等变换是三种基本变换的组合，所以只需分别对三种基本变换进行讨论即可：</p>
<ol>
<li><p>某两行互换：只影响行列式的符号，因为约定了所有多项式都是首1多项式，所以这种变换对子式集合无影响，即 $\mathscr{A}=\mathscr{B}$ ，那么必有 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>某行乘以一个非零常数：同样，因为约定了所有多项式都是首1多项式，所以也不会有影响，即 $\mathscr{A}=\mathscr{B}$ ，那么必有 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>某行乘以一个多项式再加到另一行上。假设是第 $i$ 行乘以 $h(\lambda)$ 加到第 $j$ 行。那么：</p>
<ul>
<li><p>如果 $f(\lambda)$ 没有取到第 $j$ 行，那么该子式不发生变化，即 $f(\lambda)\in\mathscr{A}$ ；</p>
</li>
<li><p>如果 $f(\lambda)$ 取到了第 $j$ 行：</p>
<ul>
<li><p>如果同时取到了第 $i$ 行，那么该子式不发生变化，即 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>如果没有取到第 $i$ 行，显然  $f(\lambda)\notin\mathscr{A}$  ，但是可以将它对应的行列式拆分：</p>
<script type="math/tex; mode=display">
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a}_j+\boldsymbol{a_i}\cdot h(\lambda) \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right| = 
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a}_j \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right|+
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a_i} \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right|\cdot h(\lambda)</script><p>即：$f(\lambda)=g(\lambda)+w(\lambda)\cdot h(\lambda)$，其中 $g(\lambda),w(\lambda)\in\mathscr{A}$ ，所以 $\mathscr{A}$ 的公因式必整除 $f(\lambda)$ </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>综上，$\mathscr{A}$ 的公因式必能整除 $\mathscr{B}$ 中的所有子式，由于初等变换可逆知，$\mathscr{B}$ 的公因式也必能整除 $\mathscr{A}$ 中的所有子式，从而二者的最高公因式相同</p>
</li>
<li><p><strong>不变因子 $d_{i}(\lambda)$</strong>  </p>
<p>记 $k$ 阶行列式因子为 $D_k(\lambda)$ ，初等变换不改变行列式因子，所以：</p>
<script type="math/tex; mode=display">
d_1(\lambda) = D_1(\lambda),\ d_i(\lambda)=D_i(\lambda)/D_{i-1}(\lambda)</script><p>因此，称 $d_i(\lambda)$ 为不变因子（行列式因子唯一，所以 $d_i(\lambda)$ 一定唯一）</p>
</li>
</ul>
</li>
</ul>
<h5 id="两种方法求Smith型"><a href="#两种方法求Smith型" class="headerlink" title="两种方法求Smith型"></a>两种方法求Smith型</h5><ul>
<li><p>初等变换：找次数最低项，要么能整除，要么能降次（带余除法）</p>
<p>例：</p>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}\lambda(\lambda+1)&0&0\\0&\lambda&0\\0&0&(\lambda+1)^2\end{bmatrix} 

&\xrightarrow[]{最低次放左上角}
&\begin{bmatrix}\lambda&0&0\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[加到第一行]{不能整除的某行}
&\begin{bmatrix}\lambda&0&(\lambda+1)^2\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[]{带余除法降次}
&\begin{bmatrix}\lambda&0&1\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[重复带余除法直到能整除]{最低次换到左上角}
&\begin{bmatrix}1&0&\lambda\\0&\lambda(\lambda+1)&0\\(\lambda+1)^2&0&0\end{bmatrix} \notag \\

&\xrightarrow[]{同行同列化零}
&\begin{bmatrix}1&0&0\\ 0&\lambda(\lambda+1)&0\\ 0&0&-\lambda(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[]{化为首1多项式}
&\begin{bmatrix}1&0&0\\ 0&\lambda(\lambda+1)&0\\ 0&0&\lambda(\lambda+1)^2\end{bmatrix} \notag \\
\end{align}</script></li>
<li><p>计算所有行列式因子</p>
<p>同上例，有 $D_1(\lambda)=1,D_2(\lambda)=\lambda(\lambda+1),D_3=\lambda^2(\lambda+1)^3$ ，故而 $d_1(\lambda)=1, d_2(\lambda)=\lambda(\lambda+1),d_3(\lambda)=\lambda(\lambda+1)^2$ </p>
</li>
</ul>
<h5 id="单位模阵可写成初等矩阵乘积"><a href="#单位模阵可写成初等矩阵乘积" class="headerlink" title="单位模阵可写成初等矩阵乘积"></a>单位模阵可写成初等矩阵乘积</h5><ul>
<li><p>单位模阵的 Smith 型为单位矩阵</p>
<p>下面给出证明：</p>
<p>$\boldsymbol{U}(\lambda)$ 是单位模阵 $\Leftrightarrow |\boldsymbol{U}(\lambda)|=c\neq0$ （为非零常数）$\Leftrightarrow\boldsymbol{U}(\lambda)$ 的 $n$ 阶行列式因子为1，且 $r=\text{rank}(\boldsymbol{U})=n$ </p>
<p>又：$D_n(\lambda)=D_1(\lambda)\frac{D_2(\lambda)}{D_1(\lambda)}\cdots\frac{D_n(\lambda)}{D_{n-1}(\lambda)}=d_1(\lambda)d_2(\lambda)\cdots d_n(\lambda)$  </p>
<p>所以：$d_i(\lambda)=1$ ，证毕</p>
</li>
</ul>
<p>据此，单位模阵经过若干次初等变换后可以变成单位矩阵，写成矩阵的形式即为：</p>
<script type="math/tex; mode=display">
\boldsymbol{P}_s(\lambda)\cdots\boldsymbol{P}_1(\lambda)\boldsymbol{U}(\lambda)\boldsymbol{Q}_1(\lambda)\cdots\boldsymbol{Q}_t(\lambda)=\boldsymbol{I}</script><p>初等矩阵的逆矩阵仍为初等矩阵，因此：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}(\lambda)=\boldsymbol{P}_1^{-1}(\lambda)\cdots\boldsymbol{P}_s^{-1}(\lambda)\boldsymbol{Q}_t^{-1}(\lambda)\boldsymbol{Q}_1^{-1}(\lambda)</script><h4 id="数域矩阵相似最简型问题"><a href="#数域矩阵相似最简型问题" class="headerlink" title="数域矩阵相似最简型问题"></a>数域矩阵相似最简型问题</h4><ul>
<li>特征矩阵：给定 $\boldsymbol{A}\in\mathbb{F}^{n\times n}$ ，称多项式矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 为矩阵 $\boldsymbol{A}$ 的特征矩阵</li>
</ul>
<h5 id="数域矩阵相似-Leftrightarrow-特征矩阵等价"><a href="#数域矩阵相似-Leftrightarrow-特征矩阵等价" class="headerlink" title="数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价"></a>数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价</h5><p>把一个受约束的相似问题【 $\boldsymbol{AP}=\boldsymbol{PB}$ 行列变换必须配套】转换成了一个不受约束的等价问题【 $\boldsymbol{U}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B}$ 行列变换无需配套】 </p>
<p>下面给出证明：</p>
<ul>
<li><p>多项式矩阵的<strong>次数</strong></p>
<p>若 $\boldsymbol{A}(\lambda) = A_0+A_1\lambda+A_2\lambda^2+\cdots+A_r\lambda^r,\ 且\ A_r\neq0$ ，则称 $\boldsymbol{A}(\lambda)$ 的次数为 $r$ ，记作 $\partial(\boldsymbol{A}(\lambda))=r$ 。特别地，零多项式矩阵的次数无意义。</p>
</li>
<li><p>多项式矩阵<strong>乘积的次数</strong> </p>
<p> $\boldsymbol{A}(\lambda)\boldsymbol{B}(\lambda)=\boldsymbol{C}(\lambda)$，且 $\boldsymbol{A}(\lambda) = A_0+A_1\lambda+\cdots+A_r\lambda^r$ ，若满足：</p>
<p>​    1）三个矩阵均非零（零矩阵的次数无意义） </p>
<p>​    2）$A_r\in \mathbb{F}^{m\times m}$ 可逆（保证 $\boldsymbol{C}(\lambda)$ 的最高次矩阵系数 $C_{r+s}(\lambda)=A_r(\lambda)B_s(\lambda)$ 非零）</p>
<p>那么 $\partial(\boldsymbol{C}(\lambda))=\partial(\boldsymbol{A}(\lambda))+\partial(\boldsymbol{B}(\lambda))$ </p>
</li>
<li><p>多项式矩阵的带余除法（以左除为例）：</p>
<p>$\boldsymbol{A}(\lambda) = A_0+A_1\lambda+\cdots+A_r\lambda^r\in(\mathbb{F}[\lambda])^{m\times m}$ ，若满足 $A_r\in\mathbb{F}^{m\times m}$ <strong>可逆</strong>，那么对非零矩阵 $\boldsymbol{B}(\lambda)\in(\mathbb{F}[\lambda])^{m\times n}$ ，存在<strong>唯一</strong>矩阵 $\boldsymbol{Q}(\lambda), \boldsymbol{R}(\lambda)$ ，使得：$\boldsymbol{B}(\lambda)=\boldsymbol{A}(\lambda)\boldsymbol{Q}(\lambda)+\boldsymbol{R}(\lambda)$ ，其中 $\boldsymbol{R}(\lambda)=\boldsymbol{0}$ 或 $\partial(\boldsymbol{R}(\lambda))&lt;\partial(\boldsymbol{A}(\lambda))$  </p>
</li>
</ul>
<p>$\Rightarrow$ ：取 $\boldsymbol{U}(\lambda)=\boldsymbol{P}^{-1},\boldsymbol{V}(\lambda)=\boldsymbol{P}$ ，因为 $\boldsymbol{P}$ 可逆，故行列式为非零常数，满足单位模阵的要求</p>
<p>$\Leftarrow$ ：从 $\boldsymbol{U},\boldsymbol{V}$ 找 $\boldsymbol{P}$ </p>
<p>根据多项式矩阵带余除法，因为 $\boldsymbol{I}$ 可逆，所以：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}(\lambda)=(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)+\boldsymbol{R}(\lambda)</script><p>其中：$\boldsymbol{R}(\lambda)=\boldsymbol{0}$ ，或 $\partial(\boldsymbol{R}(\lambda))&lt;\partial(\lambda\boldsymbol{I}-\boldsymbol{B})=1$ ，即 $\boldsymbol{R}(\lambda)=\boldsymbol{R}\in\mathbb{F}^{n\times n}$ 为常数矩阵。因此：</p>
<script type="math/tex; mode=display">
\begin{align}
&\boldsymbol{U}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B} \notag\\

\Leftrightarrow &[(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)+\boldsymbol{R}](\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B} \notag\\

\Leftrightarrow &\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})=(\lambda\boldsymbol{I}-\boldsymbol{B})[\boldsymbol{V}^{-1}(\lambda)-\boldsymbol{Q}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})] \notag

\end{align}</script><p>比较等式两端变量 $\lambda$ 的系数可知，$\boldsymbol{V}^{-1}(\lambda)-\boldsymbol{Q}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})$ 也是常数矩阵，记作 $\boldsymbol{S}$ ，故而：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})=(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{S}</script><p>且由 $\lambda$ 系数知：$\boldsymbol{R}=\boldsymbol{S}$ ，从而有 $\boldsymbol{RA}=\boldsymbol{BR}$ ，只需证 $\boldsymbol{R}$ 可逆即可</p>
<p>要证明可逆，我们期望找出一个矩阵 $\boldsymbol{P}$ ，使得 $\boldsymbol{RP}=\boldsymbol{I}$ .</p>
<p>考虑到 $\boldsymbol{R}$ 是由矩阵 $\boldsymbol{U}(\lambda)$ 对矩阵 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 作带余除法所得，对应地，也可以有：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}^{-1}(\lambda)=(\lambda\boldsymbol{I}-\boldsymbol{A})\widetilde{\boldsymbol{Q}}(\lambda)+\widetilde{\boldsymbol{R}}</script><p>将方程 (7) (10) 代入 $\boldsymbol{U}(\lambda)\boldsymbol{U}^{-1}(\lambda)=\boldsymbol{I}$ ，整理得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})\widetilde{\boldsymbol{Q}}(\lambda)+\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}-(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)\boldsymbol{U}^{-1}(\lambda)</script><p>代入方程 (9) ，整理得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}-(\lambda\boldsymbol{I}-\boldsymbol{B})[\boldsymbol{Q}(\lambda)\boldsymbol{U}^{-1}(\lambda)+\boldsymbol{S}\widetilde{\boldsymbol{Q}}(\lambda)]</script><p>比较方程 (12) 两边 $\lambda$ 系数知：$\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}$ ，从而 $\boldsymbol{R}$ 可逆。</p>
<p>证毕。</p>
<h5 id="特征矩阵的-Smith-型"><a href="#特征矩阵的-Smith-型" class="headerlink" title="特征矩阵的 Smith 型"></a>特征矩阵的 Smith 型</h5><p>因为 $|\lambda\boldsymbol{I}-\boldsymbol{A}|$ 的最高次项 $\lambda^n$ 的系数必为1，因此，$\lambda\boldsymbol{I}-\boldsymbol{A}$ 作为多项式矩阵的秩为 $n$ 。从而它的Smith型矩阵为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
d_1(\lambda)&\\
&\ddots&\\
&&d_n(\lambda)
\end{bmatrix}</script><p>因此：$d_1(\lambda)\cdots d_n(\lambda)=|\lambda\boldsymbol{I}-\boldsymbol{A}|\Rightarrow\partial(d_1(\lambda))+\cdots+\partial(d_n(\lambda))=n$ 。若某个 $d_i(\lambda)$ 的次数为 $n_i\neq1$ ，那么必将多出 $n_i-1$ 个常数不变因子，根据首1多项式的约定，这些不变因子最终都会化为1。因此上述Smith型矩阵进一步表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&&&&&\\
&\ddots&&&&\\
&&1&&&\\
&&&h_1(\lambda)&&\\
&&&&\ddots&\\
&&&&&h_p(\lambda)
\end{bmatrix}</script><p>其中，$\partial(h_i(\lambda))=n_i$ 。假设有 $p$ 个非常数不变因子，那么等于1的不变因子共有 $n-p$ 个，且满足 $n-p=(n_1-1)+\cdots+(n_p-1)$ ，因此将对角线上的元素按一个 $h_i(\lambda)$ ，$n_i-1$ 个1配对进行重组，Smith型矩阵等价于如下矩阵：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{cccc|c|cccc}
    1 & & & & & & & & \\
    & \ddots & & & & & & & \\
    & & 1 & & & & & & \\
    & & & h_1(\lambda) & & & & & \\
    \hline
    & & & & \ddots & & & & \\
    \hline
    & & & & & 1 & & & \\
    & & & & & & \ddots & & \\
    & & & & & & & 1 & \\
    & & & & & & & & h_p(\lambda)
\end{array}
\right]</script><p>每一小块都是 $\begin{bmatrix} 1&amp;&amp;&amp;\\&amp;\ddots&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;h_i(\lambda)\end{bmatrix}_{n_i\times n_i}$ </p>
<ul>
<li><p>特征矩阵的初等因子组</p>
<p>初等因子指的是将特征矩阵的所有非常数不变因子在 $\mathbb{F}[\lambda]$ 中作质因式分解时出现的质因式的方幂。所有初等因子组成初等因子组（显然初等因子组中的某个初等因子可能重复出现）。</p>
<p>$h_i(\lambda)\xlongequal{质因式分解}w_1^{r_{i1}}(\lambda)\cdots w_j^{r_{ij}}(\lambda)$ ，则每个质因式的方幂 $w_j^{r_{ij}}(\lambda)$ 就是一个初等因子，所有方幂组成了特征矩阵的初等因子组。</p>
<p>（实数域中的质因式包括 $x-c$ 和 $x^2+bx+c,且\ b^2-4c&lt;0$ 两种情况；复数域中的质因式只有 $x-c$ 一种情况）</p>
</li>
<li><p>初等因子组与不变因子（行列式因子、初等因子）互相唯一决定</p>
<p>由不变因子决定初等因子组：根据定义，显然</p>
<p>​    <strong>例</strong>：已知矩阵 $\boldsymbol{A}$ 的特征矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 的 Smith型 为：$\begin{bmatrix}1&amp;0&amp;0\\0&amp;(\lambda+1)^2&amp;0\\0&amp;0&amp;\lambda(\lambda+1)^2\end{bmatrix}$ </p>
<p>​    显然初等因子组为：$\{(\lambda+1)^2,\lambda, (\lambda+1)^2\}$</p>
<p>由初等因子组决定不变因子：</p>
<p>​    <strong>例</strong>：设 $\boldsymbol{A}\in\mathbb{C}^{8\times8}$ ，且初等因子组为：$\{\lambda,\lambda^2,\lambda,(\lambda+1)^2,(\lambda+1)^2\}$ ，求不变因子。</p>
<p>​    由于不变因子满足 $d_i(\lambda)|d_{i+1}(\lambda)$ 所以最后一个不变因子的次数应该最高且所有质因式都应出现，以此类推：</p>
<script type="math/tex; mode=display">
\begin{align}
&d_8(\lambda)=\lambda^2(\lambda+1)^2 \notag \\
&d_7(\lambda)=\lambda(\lambda+1)^2 \notag \\
&d_6(\lambda)=\lambda \notag \\
&d_5(\lambda)=\cdots=d_1(\lambda)=1 \notag
\end{align}</script></li>
</ul>
<p>下面通过对非常数不变因子 $h_i(\lambda)$ 在复数域上作质因式分解，将上述（15）进一步化为一种更特殊的形式</p>
<script type="math/tex; mode=display">
h_i(\lambda)=(\lambda-c_1)^{r_1}(\lambda-c_2)^{r_2}\cdots(\lambda-c_k)^{r_k}</script><p>显然有 $r_1+r_2+\cdots+r_k=n_i$ ，逆用初等因子分解，因为子矩阵  $\begin{bmatrix} 1&amp;&amp;&amp;\\&amp;\ddots&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;h_i(\lambda)\end{bmatrix}_{n_i\times n_i}$ 有上述 $k$ 个初等因子，所以可以等价于（有相同的初等因子组）：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{cccc|c|cccc}
    1 & & & & & & & & \\
    & \ddots & & & & & & & \\
    & & 1 & & & & & & \\
    & & & (\lambda-c_1)^{r_1} & & & & & \\
    \hline
    & & & & \ddots & & & & \\
    \hline
    & & & & & 1 & & & \\
    & & & & & & \ddots & & \\
    & & & & & & & 1 & \\
    & & & & & & & & (\lambda-c_k)^{r_k}
\end{array}
\right]</script><h5 id="矩阵相似在多项式特征邻域中的各种刻画"><a href="#矩阵相似在多项式特征邻域中的各种刻画" class="headerlink" title="矩阵相似在多项式特征邻域中的各种刻画"></a>矩阵相似在多项式特征邻域中的各种刻画</h5><p>若 $\boldsymbol{A},\boldsymbol{B}\in\mathbb{F}^{n\times n}$ ，则下列结论等价：</p>
<ol>
<li>$\boldsymbol{A}$ 与 $\boldsymbol{B}$ 相似；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 作为多项式矩阵等价；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 Smith型；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 不变因子；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 行列式因子；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 初等因子组；</li>
</ol>
<p>例：证明 $\boldsymbol{A}$ 与 $\boldsymbol{A}^T$ 相似</p>
<p>因为只提供了抽象矩阵，所以适用于具体形式的2/3/4/6方法都不容易处理，因此考虑行列式因子</p>
<p>因为 $(\lambda\boldsymbol{I}-\boldsymbol{A})^T=\lambda\boldsymbol{I}-\boldsymbol{A}^T$ ，而矩阵转置行列式不变，因此显然 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{A}^T$ 有相同的行列式因子</p>
<h5 id="多项式矩阵等价的证明方法"><a href="#多项式矩阵等价的证明方法" class="headerlink" title="多项式矩阵等价的证明方法"></a>多项式矩阵等价的证明方法</h5><ol>
<li>定义法：初等变换能否转化</li>
<li>相同的行列式因子 / Smith型 / 不变因子 / 初等因子组</li>
</ol>
<h4 id="Jordan标准型"><a href="#Jordan标准型" class="headerlink" title="Jordan标准型"></a>Jordan标准型</h4><p>以下均在复数域上考虑，因而质因式只有 $\lambda-c$ 一种类型。</p>
<p>综合上面所说，特征矩阵可以有如下等价：</p>
<script type="math/tex; mode=display">
\lambda\boldsymbol{I}-\boldsymbol{A}\sim \boldsymbol{J}(\lambda)=
\begin{bmatrix}
\boldsymbol{J}_1(\lambda) &&\\
&\ddots&\\
&&\boldsymbol{J}_q(\lambda)
\end{bmatrix},
\boldsymbol{J}_i(\lambda)=
\begin{bmatrix}
1 &&& \\
& \ddots && \\
&& 1 & \\
&&& (\lambda-c_i)^{r_i}
\end{bmatrix}_{r_i\times r_i}</script><p>其中：$(\lambda-c_i)^{r_i},i=1,…,q$ 是特征矩阵的初等因子组。</p>
<p>从而：$\boldsymbol{A}\longrightarrow\lambda\boldsymbol{I}-\boldsymbol{A}\sim\boldsymbol{J}(\lambda)\sim\lambda\boldsymbol{I}-\boldsymbol{J}\longleftarrow\boldsymbol{J}$ ，满足这个条件的矩阵都与 $\boldsymbol{A}$ 相似</p>
<p>我们要做的，就是求出其中最简单的矩阵，也就是相似最简型</p>
<p>进一步，这个问题又可以拆分成针对各个子块的类似的问题，即：求一个尽可能简单的矩阵 $\boldsymbol{J}_i\in\mathbb{C}^{r_i\times r_i}$ ，使得 $\lambda\boldsymbol{I}_{r_i}-\boldsymbol{J}_i\sim\boldsymbol{J}_i(\lambda)$ </p>
<h5 id="Jordan块的Simth型"><a href="#Jordan块的Simth型" class="headerlink" title="Jordan块的Simth型"></a>Jordan块的Simth型</h5><p>若当块：对角线元素全为 $c_1$ ，次对角线元素均为1的矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_i=\begin{bmatrix}
c_1 & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & 1 \\
0 & \cdots & \cdots& c_1
\end{bmatrix}_{r_i\times r_i}</script><p>结论：若当块所对应特征矩阵的Simth型即满足 $\lambda\boldsymbol{I}_{r_i}-\boldsymbol{J}_i\sim\boldsymbol{J}_i(\lambda)$ </p>
<p>下面给出证明（本质就是证明两个多项式矩阵等价） ：</p>
<ul>
<li>方法一：定义法</li>
</ul>
<script type="math/tex; mode=display">
左边=\begin{bmatrix}
\lambda-c_1 & -1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & -1 \\
0 & \cdots & \cdots& \lambda-c_1
\end{bmatrix}_{r_i\times r_i}</script><ul>
<li>方法二：计算两边的行列式因子</li>
</ul>
<p>由于左边的 $r_i-1$ 阶行列式中有一个是1（右上角子块），所以左边矩阵的 $r_i-1$ 阶最高公因式只能是1，即左边矩阵的 $r_i-1$ 阶行列式因子为1。</p>
<p>从而所有比它低阶的行列式因子也只能是1，因为 $D_{i-1}(\lambda)$ 必须整除 $D_{i}(\lambda)$ 。</p>
<p>而左侧行列式等于右侧行列式，即左侧 $r_i$ 阶行列式因子与右侧相同。</p>
<p>故而两边矩阵的任意阶行列式因子都相同，从而矩阵等价。</p>
<p>综上所述，有如下定理：</p>
<p>给定矩阵 $\boldsymbol{A}\in\mathbb{C}^{n\times n}$ ，其特征矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 的初等因子组为：$(\lambda-c_1)^{r_1},\cdots,(\lambda-c_q)^{r_q}$ ，取</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_i=\begin{bmatrix}
c_i & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & 1 \\
0 & \cdots & \cdots& c_i
\end{bmatrix}_{r_i\times r_i}</script><p>则 $\boldsymbol{A}$ 的相似最简型为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\sim\boldsymbol{J}=
\begin{bmatrix}
J_1 &  \cdots & 0 \\
\vdots & \ddots & \vdots \\
0 & \cdots & J_q
\end{bmatrix}</script><p>而 $\boldsymbol{J}$ 就是矩阵 $\boldsymbol{A}$ 的 Jordan标准型</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" rel="tag"># 矩阵分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/" rel="prev" title="矩阵分析学习笔记1：线性空间与线性映射">
      <i class="fa fa-chevron-left"></i> 矩阵分析学习笔记1：线性空间与线性映射
    </a></div>
      <div class="post-nav-item">
    <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E8%AE%B2-%E5%86%85%E7%A7%AF/" rel="next" title="矩阵分析学习笔记3：内积">
      矩阵分析学习笔记3：内积 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter2-lambda-%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">Chapter2 $\lambda$ 矩阵与Jordan标准型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6Smith%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">$\lambda$ 矩阵及其Smith型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E7%9F%A9%E9%98%B5"><span class="nav-number">1.1.1.</span> <span class="nav-text">$\lambda$ 矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BD%8D%E6%A8%A1%E9%98%B5%EF%BC%88%E5%B9%BA%E6%A8%A1%E9%98%B5%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">单位模阵（幺模阵）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%9D%E7%AD%89%E8%A1%8C%EF%BC%88%E5%88%97%EF%BC%89%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.3.</span> <span class="nav-text">$\lambda$ 矩阵的初等行（列）变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E7%9F%A9%E9%98%B5%E7%BB%8F%E5%B7%A6%E5%8F%B3%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E5%8C%96%E7%AE%80"><span class="nav-number">1.1.4.</span> <span class="nav-text">$\lambda$ 矩阵经左右初等变换化简</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Smith-%E5%9E%8B-lambda-%E7%9F%A9%E9%98%B5"><span class="nav-number">1.1.5.</span> <span class="nav-text">Smith 型 $\lambda$ 矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B1%82Smith%E5%9E%8B"><span class="nav-number">1.1.6.</span> <span class="nav-text">两种方法求Smith型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BD%8D%E6%A8%A1%E9%98%B5%E5%8F%AF%E5%86%99%E6%88%90%E5%88%9D%E7%AD%89%E7%9F%A9%E9%98%B5%E4%B9%98%E7%A7%AF"><span class="nav-number">1.1.7.</span> <span class="nav-text">单位模阵可写成初等矩阵乘积</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%9F%9F%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E6%9C%80%E7%AE%80%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">数域矩阵相似最简型问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%9F%9F%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC-Leftrightarrow-%E7%89%B9%E5%BE%81%E7%9F%A9%E9%98%B5%E7%AD%89%E4%BB%B7"><span class="nav-number">1.2.1.</span> <span class="nav-text">数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E7%9F%A9%E9%98%B5%E7%9A%84-Smith-%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">特征矩阵的 Smith 型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E5%9C%A8%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%B9%E5%BE%81%E9%82%BB%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%88%BB%E7%94%BB"><span class="nav-number">1.2.3.</span> <span class="nav-text">矩阵相似在多项式特征邻域中的各种刻画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9F%A9%E9%98%B5%E7%AD%89%E4%BB%B7%E7%9A%84%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.4.</span> <span class="nav-text">多项式矩阵等价的证明方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jordan%E6%A0%87%E5%87%86%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">Jordan标准型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Jordan%E5%9D%97%E7%9A%84Simth%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">Jordan块的Simth型</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="潘薇鸿"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">潘薇鸿</p>
  <div class="site-description" itemprop="description">跬步千里</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WeihongPan" title="GitHub → https://github.com/WeihongPan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘薇鸿</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
